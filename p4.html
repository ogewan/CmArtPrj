<!DOCTYPE><html>
	<head>
	<style>

@font-face {font-family:"The One True Font (System 8x12) Regular";src:url("the_one_true_font_system_8x12.eot?") format("eot"),url("the_one_true_font_system_8x12.woff") format("woff"),url("the_one_true_font_system_8x12.ttf") format("truetype"),url("the_one_true_font_system_8x12.svg#The-One-True-Font-(System-8x12)") format("svg");font-weight:normal;font-style:normal;}

* {
	/*no select*/
	/*position: fixed;*/
	-webkit-touch-callout: none;
	-webkit-user-select: none; /* Webkit */
	-moz-user-select: none;    /* Firefox */
	-ms-user-select: none;     /* IE 10  */
	/* Currently not supported in Opera but will be soon */
	-o-user-select: none;
	user-select: none;  
}
body {
    background-color: #000000;
    /*overflow:hidden;*/
	overflow: -moz-scrollbars-none;
}

::-webkit-scrollbar { 
    display: none; 
}

div {
    color: #00cc00;
	font-family: "The One True Font (System 8x12) Regular", monospace;
	font-size: 16px;
/*
border: 1px;
border-style: solid;
border-color: #00cc00/**/;
}

#console {
height: 720px;
width: 640px;
display: block;
margin:0px auto;
}

div.line {
height: 32px;
max-height: 32px;
min-height: 32px;
width: 640px;
padding: 0px;
/*border: 1px;
border-style: solid;
border-color: #ff00ff*/;
}
	</style>
	</head>
	<body>
		<div id="console">
		<p>; =============================================================================</p><p id='0' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='1' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='2' class=''>;</p><p id='3' class=''>; INIT_64</p><p id='4' class=''>; =============================================================================</p><p id='5' class=''></p><p id='6' class=''>align 16</p><p id='7' class=''>db 'DEBUG: INIT_64  '</p><p id='8' class=''>align 16</p><p id='9' class=''></p><p id='10' class=''></p><p id='11' class=''>init_64:</p><p id='12' class=''>	; Make sure that memory range 0x110000 - 0x200000 is cleared</p><p id='13' class=''>	mov rdi, os_SystemVariables</p><p id='14' class=''>	mov rcx, 122880            ; Clear 960 KiB</p><p id='15' class=''>	xor rax, rax</p><p id='16' class=''>	rep stosq                  ; Store rax to [rdi], rcx - 1, rdi + 8, if rcx > 0 then do it again</p><p id='17' class=''></p><p id='18' class=''>	mov word [os_Screen_Rows], 25</p><p id='19' class=''>	mov word [os_Screen_Cols], 80</p><p id='20' class=''>	mov rsi, 0x5080</p><p id='21' class=''>	lodsd</p><p id='22' class=''>	cmp eax, 0</p><p id='23' class=''>	je nographics</p><p id='24' class=''>	call init_screen</p><p id='25' class=''>nographics:</p><p id='26' class=''></p><p id='27' class=''>	mov word [os_Screen_Cursor_Row], 0</p><p id='28' class=''>	mov word [os_Screen_Cursor_Col], 0</p><p id='29' class=''>	call os_screen_clear		; Clear screen and display cursor</p><p id='30' class=''></p><p id='31' class=''>	; Display CPU information</p><p id='32' class=''>	mov ax, [os_Screen_Rows]</p><p id='33' class=''>	sub ax, 5</p><p id='34' class=''>	mov word [os_Screen_Cursor_Row], ax</p><p id='35' class=''>	mov word [os_Screen_Cursor_Col], 0</p><p id='36' class=''>	mov rsi, cpumsg</p><p id='37' class=''>	call os_output</p><p id='38' class=''>	xor eax, eax</p><p id='39' class=''>	mov rsi, 0x5012</p><p id='40' class=''>	lodsw</p><p id='41' class=''>	mov rdi, os_temp_string</p><p id='42' class=''>	mov rsi, rdi</p><p id='43' class=''>	call os_int_to_string</p><p id='44' class=''>	call os_output</p><p id='45' class=''>	mov rsi, coresmsg</p><p id='46' class=''>	call os_output</p><p id='47' class=''>	mov rsi, 0x5010</p><p id='48' class=''>	lodsw</p><p id='49' class=''>	mov rdi, os_temp_string</p><p id='50' class=''>	mov rsi, rdi</p><p id='51' class=''>	call os_int_to_string</p><p id='52' class=''>	call os_output</p><p id='53' class=''>	mov rsi, mhzmsg</p><p id='54' class=''>	call os_output</p><p id='55' class=''></p><p id='56' class=''>	xor rdi, rdi 			; Create the 64-bit IDT (at linear address 0x0000000000000000) as defined by Pure64</p><p id='57' class=''></p><p id='58' class=''>	; Create exception gate stubs (Pure64 has already set the correct gate markers)</p><p id='59' class=''>	mov rcx, 32</p><p id='60' class=''>	mov rax, exception_gate</p><p id='61' class=''>make_exception_gate_stubs:</p><p id='62' class=''>	call create_gate</p><p id='63' class=''>	add rdi, 1</p><p id='64' class=''>	sub rcx, 1</p><p id='65' class=''>	jnz make_exception_gate_stubs</p><p id='66' class=''></p><p id='67' class=''>	; Create interrupt gate stubs (Pure64 has already set the correct gate markers)</p><p id='68' class=''>	mov rcx, 256-32</p><p id='69' class=''>	mov rax, interrupt_gate</p><p id='70' class=''>make_interrupt_gate_stubs:</p><p id='71' class=''>	call create_gate</p><p id='72' class=''>	add rdi, 1</p><p id='73' class=''>	sub rcx, 1</p><p id='74' class=''>	jnz make_interrupt_gate_stubs</p><p id='75' class=''></p><p id='76' class=''>	; Set up the exception gates for all of the CPU exceptions</p><p id='77' class=''>	mov rcx, 20</p><p id='78' class=''>	xor rdi, rdi</p><p id='79' class=''>	mov rax, exception_gate_00</p><p id='80' class=''>make_exception_gates:</p><p id='81' class=''>	call create_gate</p><p id='82' class=''>	add rdi, 1</p><p id='83' class=''>	add rax, 16			; The exception gates are aligned at 16 bytes</p><p id='84' class=''>	sub rcx, 1</p><p id='85' class=''>	jnz make_exception_gates</p><p id='86' class=''></p><p id='87' class=''>	; Set up the IRQ handlers (Network IRQ handler is configured in init_net)</p><p id='88' class=''>	mov rdi, 0x21</p><p id='89' class=''>	mov rax, keyboard</p><p id='90' class=''>	call create_gate</p><p id='91' class=''>	mov rdi, 0x22</p><p id='92' class=''>	mov rax, cascade</p><p id='93' class=''>	call create_gate</p><p id='94' class=''>	mov rdi, 0x28</p><p id='95' class=''>	mov rax, rtc</p><p id='96' class=''>	call create_gate</p><p id='97' class=''>	mov rdi, 0x80</p><p id='98' class=''>	mov rax, ap_wakeup</p><p id='99' class=''>	call create_gate</p><p id='100' class=''>	mov rdi, 0x81</p><p id='101' class=''>	mov rax, ap_reset</p><p id='102' class=''>	call create_gate</p><p id='103' class=''></p><p id='104' class=''>	; Set up RTC</p><p id='105' class=''>	; Rate defines how often the RTC interrupt is triggered</p><p id='106' class=''>	; Rate is a 4-bit value from 1 to 15. 1 = 32768Hz, 6 = 1024Hz, 15 = 2Hz</p><p id='107' class=''>	; RTC value must stay at 32.768KHz or the computer will not keep the correct time</p><p id='108' class=''>	; http://wiki.osdev.org/RTC</p><p id='109' class=''>rtc_poll:</p><p id='110' class=''>	mov al, 0x0A			; Status Register A</p><p id='111' class=''>	out 0x70, al</p><p id='112' class=''>	in al, 0x71</p><p id='113' class=''>	test al, 0x80			; Is there an update in process?</p><p id='114' class=''>	jne rtc_poll			; If so then keep polling</p><p id='115' class=''>	mov al, 0x0A			; Status Register A</p><p id='116' class=''>	out 0x70, al</p><p id='117' class=''>	mov al, 00101101b		; RTC@32.768KHz (0010), Rate@8Hz (1101)</p><p id='118' class=''>	out 0x71, al</p><p id='119' class=''>	mov al, 0x0B			; Status Register B</p><p id='120' class=''>	out 0x70, al			; Select the address</p><p id='121' class=''>	in al, 0x71			; Read the current settings</p><p id='122' class=''>	push rax</p><p id='123' class=''>	mov al, 0x0B			; Status Register B</p><p id='124' class=''>	out 0x70, al			; Select the address</p><p id='125' class=''>	pop rax</p><p id='126' class=''>	bts ax, 6			; Set Periodic(6)</p><p id='127' class=''>	out 0x71, al			; Write the new settings</p><p id='128' class=''>	mov al, 0x0C			; Acknowledge the RTC</p><p id='129' class=''>	out 0x70, al</p><p id='130' class=''>	in al, 0x71</p><p id='131' class=''></p><p id='132' class=''>	; Set color palette</p><p id='133' class=''>	xor eax, eax</p><p id='134' class=''>	mov dx, 0x03C8			; DAC Address Write Mode Register</p><p id='135' class=''>	out dx, al</p><p id='136' class=''>	mov dx, 0x03C9			; DAC Data Register</p><p id='137' class=''>	mov rbx, 16			; 16 lines</p><p id='138' class=''>nextline:</p><p id='139' class=''>	mov rcx, 16			; 16 colors</p><p id='140' class=''>	mov rsi, palette</p><p id='141' class=''>nexttritone:</p><p id='142' class=''>	lodsb</p><p id='143' class=''>	out dx, al</p><p id='144' class=''>	lodsb</p><p id='145' class=''>	out dx, al</p><p id='146' class=''>	lodsb</p><p id='147' class=''>	out dx, al</p><p id='148' class=''>	dec rcx</p><p id='149' class=''>	cmp rcx, 0</p><p id='150' class=''>	jne nexttritone</p><p id='151' class=''>	dec rbx</p><p id='152' class=''>	cmp rbx, 0</p><p id='153' class=''>	jne nextline			; Set the next 16 colors to the same</p><p id='154' class=''>	mov eax, 0x14			; Fix for color 6</p><p id='155' class=''>	mov dx, 0x03c8			; DAC Address Write Mode Register</p><p id='156' class=''>	out dx, al</p><p id='157' class=''>	mov dx, 0x03c9			; DAC Data Register</p><p id='158' class=''>	mov rsi, palette</p><p id='159' class=''>	add rsi, 18</p><p id='160' class=''>	lodsb</p><p id='161' class=''>	out dx, al</p><p id='162' class=''>	lodsb</p><p id='163' class=''>	out dx, al</p><p id='164' class=''>	lodsb</p><p id='165' class=''>	out dx, al</p><p id='166' class=''></p><p id='167' class=''>	xor eax, eax</p><p id='168' class=''>	xor ebx, ebx</p><p id='169' class=''>	xor ecx, ecx</p><p id='170' class=''>	; Grab data from Pure64's infomap</p><p id='171' class=''>	mov rsi, 0x5008</p><p id='172' class=''>	lodsd				; Load the BSP ID</p><p id='173' class=''>	mov ebx, eax			; Save it to EBX</p><p id='174' class=''>	mov rsi, 0x5012</p><p id='175' class=''>	lodsw				; Load the number of activated cores</p><p id='176' class=''>	mov cx, ax			; Save it to CX</p><p id='177' class=''>	mov rsi, 0x5060</p><p id='178' class=''>	lodsq</p><p id='179' class=''>	mov [os_LocalAPICAddress], rax</p><p id='180' class=''>	lodsq</p><p id='181' class=''>	mov [os_IOAPICAddress], rax</p><p id='182' class=''></p><p id='183' class=''>	mov rsi, 0x5012</p><p id='184' class=''>	lodsw</p><p id='185' class=''>	mov [os_NumCores], ax</p><p id='186' class=''></p><p id='187' class=''>	mov rsi, 0x5020</p><p id='188' class=''>	lodsd</p><p id='189' class=''>	mov [os_MemAmount], eax		; In MiB's</p><p id='190' class=''></p><p id='191' class=''>	mov rsi, 0x5040</p><p id='192' class=''>	lodsq</p><p id='193' class=''>	mov [os_HPETAddress], rax</p><p id='194' class=''></p><p id='195' class=''>	; Build the OS memory table</p><p id='196' class=''>	call init_memory_map</p><p id='197' class=''></p><p id='198' class=''>	; Initialize all AP's to run our reset code. Skip the BSP</p><p id='199' class=''>	xor rax, rax</p><p id='200' class=''>	mov rsi, 0x0000000000005100	; Location in memory of the Pure64 CPU data</p><p id='201' class=''>next_ap:</p><p id='202' class=''>	cmp cx, 0</p><p id='203' class=''>	je no_more_aps</p><p id='204' class=''>	lodsb				; Load the CPU APIC ID</p><p id='205' class=''>	cmp al, bl</p><p id='206' class=''>	je skip_ap</p><p id='207' class=''>	call os_smp_reset		; Reset the CPU</p><p id='208' class=''>skip_ap:</p><p id='209' class=''>	sub cx, 1</p><p id='210' class=''>	jmp next_ap</p><p id='211' class=''></p><p id='212' class=''>no_more_aps:</p><p id='213' class=''></p><p id='214' class=''>	; Display memory information</p><p id='215' class=''>	mov rsi, memmsg</p><p id='216' class=''>	call os_output</p><p id='217' class=''>	mov eax, [os_MemAmount]		; In MiB's</p><p id='218' class=''>	mov rdi, os_temp_string</p><p id='219' class=''>	mov rsi, rdi</p><p id='220' class=''>	call os_int_to_string</p><p id='221' class=''>	call os_output</p><p id='222' class=''>	mov rsi, mibmsg</p><p id='223' class=''>	call os_output</p><p id='224' class=''></p><p id='225' class=''>	; Enable specific interrupts</p><p id='226' class=''>	mov al, 0x01			; Keyboard IRQ</p><p id='227' class=''>	call os_pic_mask_clear</p><p id='228' class=''>	mov al, 0x02			; Cascade IRQ</p><p id='229' class=''>	call os_pic_mask_clear</p><p id='230' class=''>	mov al, 0x08			; RTC IRQ</p><p id='231' class=''>	call os_pic_mask_clear</p><p id='232' class=''></p><p id='233' class=''>	ret</p><p id='234' class=''></p><p id='235' class=''>; create_gate</p><p id='236' class=''>; rax = address of handler</p><p id='237' class=''>; rdi = gate # to configure</p><p id='238' class=''>create_gate:</p><p id='239' class=''>	push rdi</p><p id='240' class=''>	push rax</p><p id='241' class=''></p><p id='242' class=''>	shl rdi, 4			; quickly multiply rdi by 16</p><p id='243' class=''>	stosw				; store the low word (15..0)</p><p id='244' class=''>	shr rax, 16</p><p id='245' class=''>	add rdi, 4			; skip the gate marker</p><p id='246' class=''>	stosw				; store the high word (31..16)</p><p id='247' class=''>	shr rax, 16</p><p id='248' class=''>	stosd				; store the high dword (63..32)</p><p id='249' class=''></p><p id='250' class=''>	pop rax</p><p id='251' class=''>	pop rdi</p><p id='252' class=''>	ret</p><p id='253' class=''></p><p id='254' class=''></p><p id='255' class=''>init_memory_map:			; Build the OS memory table</p><p id='256' class=''>	push rax</p><p id='257' class=''>	push rcx</p><p id='258' class=''>	push rdi</p><p id='259' class=''></p><p id='260' class=''>	; Build a fresh memory map for the system</p><p id='261' class=''>	mov rdi, os_MemoryMap</p><p id='262' class=''>	push rdi</p><p id='263' class=''>	xor rcx, rcx</p><p id='264' class=''>	mov cx, [os_MemAmount]</p><p id='265' class=''>	shr cx, 1			; Divide actual memory by 2</p><p id='266' class=''>	mov al, 1</p><p id='267' class=''>	rep stosb</p><p id='268' class=''>	pop rdi</p><p id='269' class=''>	mov al, 2</p><p id='270' class=''>	stosb				; Mark the first 2 MiB as in use (by Kernel and system buffers)</p><p id='271' class=''>;	stosb				; As well as the second 2 MiB (by loaded application)</p><p id='272' class=''>	; The CLI should take care of the Application memory</p><p id='273' class=''></p><p id='274' class=''>	; Allocate memory for CPU stacks (2 MiB's for each core)</p><p id='275' class=''>	xor rcx, rcx</p><p id='276' class=''>	mov cx, [os_NumCores]		; Get the amount of cores in the system</p><p id='277' class=''>	call os_mem_allocate		; Allocate a page for each core</p><p id='278' class=''>	cmp rcx, 0			; os_mem_allocate returns 0 on failure</p><p id='279' class=''>	je system_failure</p><p id='280' class=''>	add rax, 2097152</p><p id='281' class=''>	mov [os_StackBase], rax		; Store the Stack base address</p><p id='282' class=''></p><p id='283' class=''>	pop rdi</p><p id='284' class=''>	pop rcx</p><p id='285' class=''>	pop rax</p><p id='286' class=''>	ret</p><p id='287' class=''></p><p id='288' class=''></p><p id='289' class=''>system_failure:</p><p id='290' class=''>	mov rsi, memory_message</p><p id='291' class=''>	call os_output</p><p id='292' class=''>system_failure_hang:</p><p id='293' class=''>	hlt</p><p id='294' class=''>	jmp system_failure_hang</p><p id='295' class=''>	ret</p><p id='296' class=''></p><p id='297' class=''></p><p id='298' class=''>; -----------------------------------------------------------------------------</p><p id='299' class=''>init_screen:</p><p id='300' class=''>	mov rsi, 0x5080</p><p id='301' class=''>	xor eax, eax</p><p id='302' class=''>	lodsd				; VIDEO_BASE</p><p id='303' class=''>	mov [os_VideoBase], rax</p><p id='304' class=''>	xor eax, eax</p><p id='305' class=''>	xor ecx, ecx</p><p id='306' class=''></p><p id='307' class=''>	lodsw				; VIDEO_X</p><p id='308' class=''>	mov [os_VideoX], ax		; ex: 1024</p><p id='309' class=''></p><p id='310' class=''>	xor edx, edx</p><p id='311' class=''>	mov cl, [font_width]</p><p id='312' class=''>	div cx</p><p id='313' class=''>	mov [os_Screen_Cols], ax</p><p id='314' class=''></p><p id='315' class=''>	lodsw				; VIDEO_Y</p><p id='316' class=''>	mov [os_VideoY], ax		; ex: 768</p><p id='317' class=''></p><p id='318' class=''>	xor edx, edx</p><p id='319' class=''>	mov cl, [font_height]</p><p id='320' class=''>	div cx</p><p id='321' class=''>	mov [os_Screen_Rows], ax</p><p id='322' class=''></p><p id='323' class=''>	lodsb				; VIDEO_DEPTH</p><p id='324' class=''>	mov [os_VideoDepth], al</p><p id='325' class=''></p><p id='326' class=''>	xor eax, eax</p><p id='327' class=''>	xor ecx, ecx</p><p id='328' class=''>	mov ax, [os_VideoX]</p><p id='329' class=''>	mov cx, [os_VideoY]</p><p id='330' class=''>	mul ecx</p><p id='331' class=''>	mov [os_Screen_Pixels], eax</p><p id='332' class=''>	xor ecx, ecx</p><p id='333' class=''>	mov cl, [os_VideoDepth]</p><p id='334' class=''>	shr cl, 3</p><p id='335' class=''>	mul ecx</p><p id='336' class=''>	mov [os_Screen_Bytes], eax</p><p id='337' class=''></p><p id='338' class=''>	xor eax, eax</p><p id='339' class=''>	xor ecx, ecx</p><p id='340' class=''>	mov ax, [os_VideoX]</p><p id='341' class=''>	mov cl, [font_height]</p><p id='342' class=''>	mul cx</p><p id='343' class=''>	mov cl, [os_VideoDepth]</p><p id='344' class=''>	shr cl, 3</p><p id='345' class=''>	mul ecx</p><p id='346' class=''>	mov dword [os_Screen_Row_2], eax</p><p id='347' class=''></p><p id='348' class=''>	mov eax, 0x00FFFFFF</p><p id='349' class=''>	mov [os_Font_Color], eax</p><p id='350' class=''></p><p id='351' class=''>	mov al, 1</p><p id='352' class=''>	mov [os_VideoEnabled], al</p><p id='353' class=''></p><p id='354' class=''>	ret</p><p id='355' class=''>; -----------------------------------------------------------------------------</p><p id='356' class=''></p><p id='357' class=''></p><p id='358' class=''>; =============================================================================</p><p id='359' class=''>; EOHEF</p><p id='360' class=''>; =============================================================================</p><p id='361' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='362' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='363' class=''>;</p><p id='364' class=''>; INIT_NET</p><p id='365' class=''>; =============================================================================</p><p id='366' class=''></p><p id='367' class=''>align 16</p><p id='368' class=''>db 'DEBUG: INIT_NET '</p><p id='369' class=''>align 16</p><p id='370' class=''></p><p id='371' class=''></p><p id='372' class=''>init_net:</p><p id='373' class=''>	mov rsi, networkmsg</p><p id='374' class=''>	call os_output</p><p id='375' class=''></p><p id='376' class=''>	; Search for a supported NIC</p><p id='377' class=''>	xor ebx, ebx			; Clear the Bus number</p><p id='378' class=''>	xor ecx, ecx			; Clear the Device/Slot number</p><p id='379' class=''>	mov edx, 2			; Register 2 for Class code/Subclass</p><p id='380' class=''></p><p id='381' class=''>init_net_probe_next:</p><p id='382' class=''>	call os_pci_read_reg</p><p id='383' class=''>	shr eax, 16			; Move the Class/Subclass code to AX</p><p id='384' class=''>	cmp ax, 0x0200			; Network Controller (02) / Ethernet (00)</p><p id='385' class=''>	je init_net_probe_find_driver	; Found a Network Controller... now search for a driver</p><p id='386' class=''>	add ecx, 1</p><p id='387' class=''>	cmp ecx, 256			; Maximum 256 devices/functions per bus</p><p id='388' class=''>	je init_net_probe_next_bus</p><p id='389' class=''>	jmp init_net_probe_next</p><p id='390' class=''></p><p id='391' class=''>init_net_probe_next_bus:</p><p id='392' class=''>	xor ecx, ecx</p><p id='393' class=''>	add ebx, 1</p><p id='394' class=''>	cmp ebx, 256			; Maximum 256 buses</p><p id='395' class=''>	je init_net_probe_not_found</p><p id='396' class=''>	jmp init_net_probe_next</p><p id='397' class=''></p><p id='398' class=''>init_net_probe_find_driver:</p><p id='399' class=''>	xor edx, edx				; Register 0 for Device/Vendor ID</p><p id='400' class=''>	call os_pci_read_reg			; Read the Device/Vendor ID from the PCI device</p><p id='401' class=''>	mov r8d, eax				; Save the Device/Vendor ID in R8D</p><p id='402' class=''>	mov rsi, NIC_DeviceVendor_ID</p><p id='403' class=''>	lodsd					; Load a driver ID - Low half must be 0xFFFF</p><p id='404' class=''>init_net_probe_find_next_driver:</p><p id='405' class=''>	mov rdx, rax				; Save the driver ID</p><p id='406' class=''>init_net_probe_find_next_device:</p><p id='407' class=''>	lodsd					; Load a device and vendor ID from our list of supported NICs</p><p id='408' class=''>	cmp eax, 0x00000000			; 0x00000000 means we have reached the end of the list</p><p id='409' class=''>	je init_net_probe_not_found		; No supported NIC found</p><p id='410' class=''>	cmp ax, 0xFFFF				; New driver ID?</p><p id='411' class=''>	je init_net_probe_find_next_driver	; We found the next driver type</p><p id='412' class=''>	cmp eax, r8d</p><p id='413' class=''>	je init_net_probe_found			; If Carry is clear then we found a supported NIC</p><p id='414' class=''>	jmp init_net_probe_find_next_device	; Check the next device</p><p id='415' class=''></p><p id='416' class=''>init_net_probe_found:</p><p id='417' class=''>	cmp edx, 0x8169FFFF</p><p id='418' class=''>	je init_net_probe_found_rtl8169</p><p id='419' class=''>	cmp edx, 0x8254FFFF</p><p id='420' class=''>	je init_net_probe_found_i8254x</p><p id='421' class=''>	jmp init_net_probe_not_found</p><p id='422' class=''></p><p id='423' class=''>init_net_probe_found_rtl8169:</p><p id='424' class=''>	call os_net_rtl8169_init</p><p id='425' class=''>	mov rdi, os_net_transmit</p><p id='426' class=''>	mov rax, os_net_rtl8169_transmit</p><p id='427' class=''>	stosq</p><p id='428' class=''>	mov rax, os_net_rtl8169_poll</p><p id='429' class=''>	stosq</p><p id='430' class=''>	mov rax, os_net_rtl8169_ack_int</p><p id='431' class=''>	stosq</p><p id='432' class=''>	jmp init_net_probe_found_finish</p><p id='433' class=''></p><p id='434' class=''>init_net_probe_found_i8254x:</p><p id='435' class=''>	call os_net_i8254x_init</p><p id='436' class=''>	mov rdi, os_net_transmit</p><p id='437' class=''>	mov rax, os_net_i8254x_transmit</p><p id='438' class=''>	stosq</p><p id='439' class=''>	mov rax, os_net_i8254x_poll</p><p id='440' class=''>	stosq</p><p id='441' class=''>	mov rax, os_net_i8254x_ack_int</p><p id='442' class=''>	stosq</p><p id='443' class=''>	jmp init_net_probe_found_finish</p><p id='444' class=''></p><p id='445' class=''>init_net_probe_found_finish:</p><p id='446' class=''>	xor eax, eax</p><p id='447' class=''>	mov al, [os_NetIRQ]</p><p id='448' class=''></p><p id='449' class=''>	add al, 0x20</p><p id='450' class=''>	mov rdi, rax</p><p id='451' class=''>	mov rax, network</p><p id='452' class=''>	call create_gate</p><p id='453' class=''></p><p id='454' class=''>	; Enable the Network IRQ</p><p id='455' class=''>	mov al, [os_NetIRQ]</p><p id='456' class=''>	call os_pic_mask_clear</p><p id='457' class=''></p><p id='458' class=''>	mov byte [os_NetEnabled], 1	; A supported NIC was found. Signal to the OS that networking is enabled</p><p id='459' class=''>	call os_ethernet_ack_int	; Call the driver function to acknowledge the interrupt internally</p><p id='460' class=''></p><p id='461' class=''>	mov cl, 6</p><p id='462' class=''>	mov rsi, os_NetMAC</p><p id='463' class=''>nextbyte:</p><p id='464' class=''>	lodsb</p><p id='465' class=''>	call os_debug_dump_al</p><p id='466' class=''>	sub cl, 1</p><p id='467' class=''>	cmp cl, 0</p><p id='468' class=''>	jne nextbyte</p><p id='469' class=''>	mov rsi, closebracketmsg</p><p id='470' class=''>	call os_output</p><p id='471' class=''>	ret</p><p id='472' class=''>	</p><p id='473' class=''>init_net_probe_not_found:</p><p id='474' class=''>	mov rsi, namsg</p><p id='475' class=''>	call os_output</p><p id='476' class=''>	mov rsi, closebracketmsg</p><p id='477' class=''>	call os_output</p><p id='478' class=''>	ret</p><p id='479' class=''></p><p id='480' class=''></p><p id='481' class=''>; =============================================================================</p><p id='482' class=''>; EOHEF</p><p id='483' class=''>; =============================================================================</p><p id='484' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='485' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='486' class=''>;</p><p id='487' class=''>; BMFS Functions</p><p id='488' class=''>; =============================================================================</p><p id='489' class=''></p><p id='490' class=''>align 16</p><p id='491' class=''>db 'DEBUG: BMFS     '</p><p id='492' class=''>align 16</p><p id='493' class=''></p><p id='494' class=''></p><p id='495' class=''>; -----------------------------------------------------------------------------</p><p id='496' class=''>; init_bmfs -- Initialize the BMFS driver</p><p id='497' class=''>init_bmfs:</p><p id='498' class=''>	push rdi</p><p id='499' class=''>	push rdx</p><p id='500' class=''>	push rcx</p><p id='501' class=''>	push rax</p><p id='502' class=''></p><p id='503' class=''>	mov byte [bmfs_directory], 0</p><p id='504' class=''></p><p id='505' class=''>	cmp byte [os_DiskEnabled], 0x01</p><p id='506' class=''>	jne init_bmfs_nodisk</p><p id='507' class=''></p><p id='508' class=''>	; Read directory to memory</p><p id='509' class=''>	mov rax, 8			; Start to read from 4K in</p><p id='510' class=''>	mov rcx, 8			; Read 8 sectors (4KiB)</p><p id='511' class=''>	xor edx, edx			; Read from drive 0</p><p id='512' class=''>	mov rdi, bmfs_directory</p><p id='513' class=''>	call readsectors</p><p id='514' class=''></p><p id='515' class=''>	; Get total blocks</p><p id='516' class=''>	mov eax, [hd1_size]		; in mebibytes (MiB)</p><p id='517' class=''>	shr rax, 1</p><p id='518' class=''>	mov [bmfs_TotalBlocks], rax</p><p id='519' class=''></p><p id='520' class=''>init_bmfs_nodisk:</p><p id='521' class=''></p><p id='522' class=''>	pop rax</p><p id='523' class=''>	pop rcx</p><p id='524' class=''>	pop rdx</p><p id='525' class=''>	pop rdi</p><p id='526' class=''>	ret</p><p id='527' class=''>; -----------------------------------------------------------------------------</p><p id='528' class=''></p><p id='529' class=''></p><p id='530' class=''>; -----------------------------------------------------------------------------</p><p id='531' class=''>; os_file_open -- Open a file on disk</p><p id='532' class=''>; IN:	RSI = File name (zero-terminated string)</p><p id='533' class=''>; OUT:	RAX = File I/O handler, 0 on error</p><p id='534' class=''>;	All other registers preserved</p><p id='535' class=''>os_bmfs_file_open:</p><p id='536' class=''>	push rsi</p><p id='537' class=''>	push rdx</p><p id='538' class=''>	push rcx</p><p id='539' class=''>	push rbx</p><p id='540' class=''></p><p id='541' class=''>	; Query the existence</p><p id='542' class=''>	call os_bmfs_file_internal_query</p><p id='543' class=''>	jc os_bmfs_file_open_error</p><p id='544' class=''>	mov rax, rbx			; Slot #</p><p id='545' class=''>	add rax, 10			; Files start at 10</p><p id='546' class=''></p><p id='547' class=''>	; Is it already open? If not, mark as open</p><p id='548' class=''>	mov rsi, os_filehandlers</p><p id='549' class=''>	add rsi, rbx</p><p id='550' class=''>	cmp byte [rsi], 0		; 0 is closed</p><p id='551' class=''>	jne os_bmfs_file_open_error</p><p id='552' class=''>	mov byte [rsi], 1		; Set to open</p><p id='553' class=''></p><p id='554' class=''>	; Reset the seek</p><p id='555' class=''>	mov rsi, os_filehandlers_seek</p><p id='556' class=''>	shl rbx, 3			; Quick multiply by 8</p><p id='557' class=''>	add rsi, rbx</p><p id='558' class=''>	xor ebx, ebx			; SEEK_START</p><p id='559' class=''>	mov qword [rsi], rbx</p><p id='560' class=''></p><p id='561' class=''>	jmp os_bmfs_file_open_done</p><p id='562' class=''></p><p id='563' class=''>os_bmfs_file_open_error:</p><p id='564' class=''>	xor eax, eax</p><p id='565' class=''></p><p id='566' class=''>os_bmfs_file_open_done:</p><p id='567' class=''>	pop rbx</p><p id='568' class=''>	pop rcx</p><p id='569' class=''>	pop rdx</p><p id='570' class=''>	pop rsi</p><p id='571' class=''>	ret</p><p id='572' class=''>; -----------------------------------------------------------------------------</p><p id='573' class=''></p><p id='574' class=''></p><p id='575' class=''>; -----------------------------------------------------------------------------</p><p id='576' class=''>; os_file_close -- Close an open file</p><p id='577' class=''>; IN:	RAX = File I/O handler</p><p id='578' class=''>; OUT:	All registers preserved</p><p id='579' class=''>os_bmfs_file_close:</p><p id='580' class=''>	push rsi</p><p id='581' class=''>	push rax</p><p id='582' class=''></p><p id='583' class=''>	; Is it in the valid file handler range?</p><p id='584' class=''>	sub rax, 10			; Subtract the handler offset</p><p id='585' class=''>	cmp rax, 64			; BMFS has up to 64 files</p><p id='586' class=''>	jg os_bmfs_file_close_error</p><p id='587' class=''></p><p id='588' class=''>	; Mark as closed</p><p id='589' class=''>	mov rsi, os_filehandlers</p><p id='590' class=''>	add rsi, rax</p><p id='591' class=''>	mov byte [rsi], 0		; Set to closed</p><p id='592' class=''></p><p id='593' class=''>os_bmfs_file_close_error:</p><p id='594' class=''></p><p id='595' class=''>os_bmfs_file_close_done:</p><p id='596' class=''>	pop rax</p><p id='597' class=''>	pop rsi</p><p id='598' class=''>	ret</p><p id='599' class=''>; -----------------------------------------------------------------------------</p><p id='600' class=''></p><p id='601' class=''></p><p id='602' class=''>; -----------------------------------------------------------------------------</p><p id='603' class=''>; os_bmfs_file_read -- Read a number of bytes from a file</p><p id='604' class=''>; IN:	RAX = File I/O handler</p><p id='605' class=''>;	RCX = Number of bytes to read (automatically rounded up to next 2MiB)</p><p id='606' class=''>;	RDI = Destination memory address</p><p id='607' class=''>; OUT:	RCX = Number of bytes read</p><p id='608' class=''>;	All other registers preserved</p><p id='609' class=''>os_bmfs_file_read:</p><p id='610' class=''>	push rdi</p><p id='611' class=''>	push rsi</p><p id='612' class=''>	push rdx</p><p id='613' class=''>	push rcx</p><p id='614' class=''>	push rbx</p><p id='615' class=''>	push rax</p><p id='616' class=''></p><p id='617' class=''>	; Is it a valid read?</p><p id='618' class=''>	cmp rcx, 0</p><p id='619' class=''>	je os_bmfs_file_read_error</p><p id='620' class=''></p><p id='621' class=''>	; Is it in the valid file handler range?</p><p id='622' class=''>	sub rax, 10			; Subtract the handler offset</p><p id='623' class=''>	mov rbx, rax			; Keep the file ID</p><p id='624' class=''>	cmp rax, 64			; BMFS has up to 64 files</p><p id='625' class=''>	jg os_bmfs_file_read_error</p><p id='626' class=''></p><p id='627' class=''>	; Is this an open file?</p><p id='628' class=''>	mov rsi, os_filehandlers</p><p id='629' class=''>	add rsi, rax</p><p id='630' class=''>	cmp byte [rsi], 0</p><p id='631' class=''>	je os_bmfs_file_read_error</p><p id='632' class=''></p><p id='633' class=''>	; Get the starting block</p><p id='634' class=''>	mov rsi, bmfs_directory		; Beginning of directory structure</p><p id='635' class=''>	shl rax, 6			; Quickly multiply by 64 (size of BMFS record)</p><p id='636' class=''>	add rsi, rax</p><p id='637' class=''>	add rsi, 32			; Offset to starting block</p><p id='638' class=''>	lodsq				; Load starting block in RAX</p><p id='639' class=''></p><p id='640' class=''>	; Add the current offset</p><p id='641' class=''>	; Currently always starting from start</p><p id='642' class=''></p><p id='643' class=''>	; Round up 'bytes to read' to the next 2MiB block</p><p id='644' class=''>	add rcx, 2097151		; 2MiB - 1 byte</p><p id='645' class=''>	shr rcx, 21			; Quick divide by 2097152</p><p id='646' class=''></p><p id='647' class=''>	; Read the block(s)</p><p id='648' class=''>	xor edx, edx			; Drive 0</p><p id='649' class=''>	call os_bmfs_block_read</p><p id='650' class=''>	jmp os_bmfs_file_read_done</p><p id='651' class=''></p><p id='652' class=''>os_bmfs_file_read_error:</p><p id='653' class=''>	xor ecx, ecx</p><p id='654' class=''></p><p id='655' class=''>os_bmfs_file_read_done:</p><p id='656' class=''></p><p id='657' class=''>	; Increment the offset</p><p id='658' class=''></p><p id='659' class=''>	pop rax</p><p id='660' class=''>	pop rbx</p><p id='661' class=''>	pop rcx</p><p id='662' class=''>	pop rdx</p><p id='663' class=''>	pop rsi</p><p id='664' class=''>	pop rdi</p><p id='665' class=''>	ret</p><p id='666' class=''>; -----------------------------------------------------------------------------</p><p id='667' class=''></p><p id='668' class=''></p><p id='669' class=''>; -----------------------------------------------------------------------------</p><p id='670' class=''>; os_bmfs_file_write -- Write a number of bytes to a file</p><p id='671' class=''>; IN:	RAX = File I/O handler</p><p id='672' class=''>;	RCX = Number of bytes to write</p><p id='673' class=''>;	RSI = Source memory address</p><p id='674' class=''>; OUT:	RCX = Number of bytes written</p><p id='675' class=''>;	All other registers preserved</p><p id='676' class=''>os_bmfs_file_write:</p><p id='677' class=''>	push rdi</p><p id='678' class=''>	push rsi</p><p id='679' class=''>	push rdx</p><p id='680' class=''>	push rcx</p><p id='681' class=''>	push rbx</p><p id='682' class=''>	push rax</p><p id='683' class=''></p><p id='684' class=''>	; Is it a valid write?</p><p id='685' class=''>	cmp rcx, 0</p><p id='686' class=''>	je os_bmfs_file_write_error</p><p id='687' class=''></p><p id='688' class=''>	; Is it in the valid file handler range?</p><p id='689' class=''>	sub rax, 10			; Subtract the handler offset</p><p id='690' class=''>	mov rbx, rax			; Keep the file ID</p><p id='691' class=''>	cmp rax, 64			; BMFS has up to 64 files</p><p id='692' class=''>	jg os_bmfs_file_write_error</p><p id='693' class=''></p><p id='694' class=''>	; Is this an open file?</p><p id='695' class=''>	mov rdi, os_filehandlers</p><p id='696' class=''>	add rdi, rax</p><p id='697' class=''>	cmp byte [rdi], 0</p><p id='698' class=''>	je os_bmfs_file_write_error</p><p id='699' class=''></p><p id='700' class=''>	; Flush directory to disk</p><p id='701' class=''></p><p id='702' class=''>os_bmfs_file_write_error:</p><p id='703' class=''>	xor ecx, ecx</p><p id='704' class=''></p><p id='705' class=''>os_bmfs_file_write_done:</p><p id='706' class=''></p><p id='707' class=''>	pop rax</p><p id='708' class=''>	pop rbx</p><p id='709' class=''>	pop rcx</p><p id='710' class=''>	pop rdx</p><p id='711' class=''>	pop rsi</p><p id='712' class=''>	pop rdi</p><p id='713' class=''>	ret</p><p id='714' class=''>; -----------------------------------------------------------------------------</p><p id='715' class=''></p><p id='716' class=''></p><p id='717' class=''>; -----------------------------------------------------------------------------</p><p id='718' class=''>; os_bmfs_file_seek -- Seek to position in a file</p><p id='719' class=''>; IN:	RAX = File I/O handler</p><p id='720' class=''>;	RCX = Number of bytes to offset from origin</p><p id='721' class=''>;	RDX = Origin</p><p id='722' class=''>; OUT:	All registers preserved</p><p id='723' class=''>os_bmfs_file_seek:</p><p id='724' class=''>	; Is this an open file?</p><p id='725' class=''></p><p id='726' class=''>	ret</p><p id='727' class=''>; -----------------------------------------------------------------------------</p><p id='728' class=''></p><p id='729' class=''></p><p id='730' class=''>; -----------------------------------------------------------------------------</p><p id='731' class=''>; os_bmfs_file_internal_query -- Search for a file name and return information</p><p id='732' class=''>; IN:	RSI = Pointer to file name</p><p id='733' class=''>; OUT:	RAX = Staring block number</p><p id='734' class=''>;	RBX = Offset to entry</p><p id='735' class=''>;	RCX = File size in bytes</p><p id='736' class=''>;	RDX = Reserved blocks</p><p id='737' class=''>;	Carry set if not found. If carry is set then ignore returned values</p><p id='738' class=''>os_bmfs_file_internal_query:</p><p id='739' class=''>	push rdi</p><p id='740' class=''></p><p id='741' class=''>	clc				; Clear carry</p><p id='742' class=''>	mov rdi, bmfs_directory		; Beginning of directory structure</p><p id='743' class=''></p><p id='744' class=''>os_bmfs_file_internal_query_next:</p><p id='745' class=''>	call os_string_compare</p><p id='746' class=''>	jc os_bmfs_file_internal_query_found</p><p id='747' class=''>	add rdi, 64			; Next record</p><p id='748' class=''>	cmp rdi, bmfs_directory + 0x1000	; End of directory</p><p id='749' class=''>	jne os_bmfs_file_internal_query_next</p><p id='750' class=''>	stc				; Set flag for file not found</p><p id='751' class=''>	pop rdi</p><p id='752' class=''>	ret</p><p id='753' class=''></p><p id='754' class=''>os_bmfs_file_internal_query_found:</p><p id='755' class=''>	clc				; Clear flag for file found</p><p id='756' class=''>	mov rbx, rdi</p><p id='757' class=''>	sub rbx, bmfs_directory</p><p id='758' class=''>	shr rbx, 6				; Quick divide by 64 for offset (entry) number</p><p id='759' class=''>	mov rdx, [rdi + BMFS_DirEnt.reserved]	; Reserved blocks</p><p id='760' class=''>	mov rcx, [rdi + BMFS_DirEnt.size]	; Size in bytes</p><p id='761' class=''>	mov rax, [rdi + BMFS_DirEnt.start]	; Starting block number</p><p id='762' class=''></p><p id='763' class=''>	pop rdi</p><p id='764' class=''>	ret</p><p id='765' class=''>; -----------------------------------------------------------------------------</p><p id='766' class=''></p><p id='767' class=''></p><p id='768' class=''>; -----------------------------------------------------------------------------</p><p id='769' class=''>; os_bmfs_file_query -- Search for a file name and return information</p><p id='770' class=''>; IN:	RSI = Pointer to file name</p><p id='771' class=''>; OUT:	RCX = File size in bytes</p><p id='772' class=''>;	Carry set if not found. If carry is set then ignore returned values</p><p id='773' class=''>os_bmfs_file_query:</p><p id='774' class=''>	push rdi</p><p id='775' class=''></p><p id='776' class=''>	clc				; Clear carry</p><p id='777' class=''>	mov rdi, bmfs_directory		; Beginning of directory structure</p><p id='778' class=''></p><p id='779' class=''>os_bmfs_file_query_next:</p><p id='780' class=''>	call os_string_compare</p><p id='781' class=''>	jc os_bmfs_file_query_found</p><p id='782' class=''>	add rdi, 64			; Next record</p><p id='783' class=''>	cmp rdi, bmfs_directory + 0x1000	; End of directory</p><p id='784' class=''>	jne os_bmfs_file_query_next</p><p id='785' class=''>	stc				; Set flag for file not found</p><p id='786' class=''>	pop rdi</p><p id='787' class=''>	ret</p><p id='788' class=''></p><p id='789' class=''>os_bmfs_file_query_found:</p><p id='790' class=''>	clc				; Clear flag for file found</p><p id='791' class=''>	mov rcx, [rdi + BMFS_DirEnt.size]	; Size in bytes</p><p id='792' class=''></p><p id='793' class=''>	pop rdi</p><p id='794' class=''>	ret</p><p id='795' class=''>; -----------------------------------------------------------------------------</p><p id='796' class=''></p><p id='797' class=''></p><p id='798' class=''>; -----------------------------------------------------------------------------</p><p id='799' class=''>; os_bmfs_file_create -- Create a file on the hard disk</p><p id='800' class=''>; IN:	RSI = Pointer to file name, must be <= 32 characters</p><p id='801' class=''>;	RCX = File size to reserve (rounded up to the nearest 2MiB)</p><p id='802' class=''>; OUT:	Carry clear on success, set on failure</p><p id='803' class=''>; Note:	This function pre-allocates all blocks required for the file</p><p id='804' class=''>os_bmfs_file_create:</p><p id='805' class=''></p><p id='806' class=''>	; Flush directory to disk</p><p id='807' class=''></p><p id='808' class=''>	ret</p><p id='809' class=''>; -----------------------------------------------------------------------------</p><p id='810' class=''></p><p id='811' class=''></p><p id='812' class=''>; -----------------------------------------------------------------------------</p><p id='813' class=''>; os_bmfs_file_delete -- Delete a file from the hard disk</p><p id='814' class=''>; IN:	RSI = File name to delete</p><p id='815' class=''>; OUT:	Carry clear on success, set on failure</p><p id='816' class=''>os_bmfs_file_delete:</p><p id='817' class=''>	push rdx</p><p id='818' class=''>	push rcx</p><p id='819' class=''>	push rbx</p><p id='820' class=''>	push rax</p><p id='821' class=''></p><p id='822' class=''>	call os_bmfs_file_internal_query</p><p id='823' class=''>	jc os_bmfs_file_delete_notfound</p><p id='824' class=''></p><p id='825' class=''>	mov byte [rbx + BMFS_DirEnt.filename], 0x01 ; Add deleted marker to file name</p><p id='826' class=''></p><p id='827' class=''>	; Flush directory to disk</p><p id='828' class=''></p><p id='829' class=''>os_bmfs_file_delete_notfound:</p><p id='830' class=''>	pop rax</p><p id='831' class=''>	pop rbx</p><p id='832' class=''>	pop rcx</p><p id='833' class=''>	pop rdx</p><p id='834' class=''>	ret</p><p id='835' class=''>; -----------------------------------------------------------------------------</p><p id='836' class=''></p><p id='837' class=''></p><p id='838' class=''>; -----------------------------------------------------------------------------</p><p id='839' class=''>; os_bmfs_block_read -- Read a number of blocks into memory</p><p id='840' class=''>; IN:	RAX = Starting block #</p><p id='841' class=''>;	RCX = Number of blocks to read</p><p id='842' class=''>;	RDI = Memory location to store blocks</p><p id='843' class=''>; OUT:	</p><p id='844' class=''>os_bmfs_block_read:</p><p id='845' class=''>	cmp rcx, 0</p><p id='846' class=''>	je os_bmfs_block_read_done	; Bail out if instructed to read nothing</p><p id='847' class=''></p><p id='848' class=''>	; Calculate the starting sector</p><p id='849' class=''>	shl rax, 12			; Multiply block start count by 4096 to get sector start count</p><p id='850' class=''></p><p id='851' class=''>	; Calculate sectors to read</p><p id='852' class=''>	shl rcx, 12			; Multiply block count by 4096 to get number of sectors to read</p><p id='853' class=''>	mov rbx, rcx</p><p id='854' class=''>	</p><p id='855' class=''>os_bmfs_block_read_loop:</p><p id='856' class=''>	mov rcx, 4096			; Read 2MiB at a time (4096 512-byte sectors = 2MiB)</p><p id='857' class=''>	call readsectors</p><p id='858' class=''>	sub rbx, 4096</p><p id='859' class=''>	jnz os_bmfs_block_read_loop</p><p id='860' class=''></p><p id='861' class=''>os_bmfs_block_read_done:</p><p id='862' class=''>	ret</p><p id='863' class=''>; -----------------------------------------------------------------------------</p><p id='864' class=''></p><p id='865' class=''></p><p id='866' class=''>; -----------------------------------------------------------------------------</p><p id='867' class=''>; os_bmfs_block_write -- Write a number of blocks to disk</p><p id='868' class=''>; IN:	RAX = Starting block #</p><p id='869' class=''>;	RCX = Number of blocks to write</p><p id='870' class=''>;	RSI = Memory location of blocks to store</p><p id='871' class=''>; OUT:	</p><p id='872' class=''>os_bmfs_block_write:</p><p id='873' class=''>	cmp rcx, 0</p><p id='874' class=''>	je os_bmfs_block_write_done	; Bail out if instructed to write nothing	</p><p id='875' class=''></p><p id='876' class=''>	; Calculate the starting sector</p><p id='877' class=''>	shl rax, 12			; Multiply block start count by 4096 to get sector start count</p><p id='878' class=''></p><p id='879' class=''>	; Calculate sectors to write</p><p id='880' class=''>	shl rcx, 12			; Multiply block count by 4096 to get number of sectors to write</p><p id='881' class=''>	mov rbx, rcx</p><p id='882' class=''>	</p><p id='883' class=''>os_bmfs_block_write_loop:</p><p id='884' class=''>	mov rcx, 4096			; Write 2MiB at a time (4096 512-byte sectors = 2MiB)</p><p id='885' class=''>	call writesectors</p><p id='886' class=''>	sub rbx, 4096</p><p id='887' class=''>	jnz os_bmfs_block_write_loop</p><p id='888' class=''></p><p id='889' class=''>os_bmfs_block_write_done:</p><p id='890' class=''>	ret</p><p id='891' class=''>; -----------------------------------------------------------------------------</p><p id='892' class=''></p><p id='893' class=''></p><p id='894' class=''>; =============================================================================</p><p id='895' class=''>; EOHEF</p><p id='896' class=''>; =============================================================================</p><p id='897' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='898' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='899' class=''>;</p><p id='900' class=''>; Intel i8254x NIC.</p><p id='901' class=''>; =============================================================================</p><p id='902' class=''></p><p id='903' class=''>align 16</p><p id='904' class=''>db 'DEBUG: I8254X   '</p><p id='905' class=''>align 16</p><p id='906' class=''></p><p id='907' class=''></p><p id='908' class=''>; -----------------------------------------------------------------------------</p><p id='909' class=''>; Initialize an Intel 8254x NIC</p><p id='910' class=''>;  IN:	BL  = Bus number of the Intel device</p><p id='911' class=''>;	CL  = Device/Slot number of the Intel device</p><p id='912' class=''>os_net_i8254x_init:</p><p id='913' class=''>	push rsi</p><p id='914' class=''>	push rdx</p><p id='915' class=''>	push rcx</p><p id='916' class=''>	push rax</p><p id='917' class=''></p><p id='918' class=''>	; Read BAR4, If BAR4 is all 0'z then we are using 32-bit addresses</p><p id='919' class=''></p><p id='920' class=''>	; Grab the Base I/O Address of the device</p><p id='921' class=''>	mov dl, 0x04				; BAR0</p><p id='922' class=''>	call os_pci_read_reg</p><p id='923' class=''>	and eax, 0xFFFFFFF0			; EAX now holds the Base Memory IO Address (clear the low 4 bits)</p><p id='924' class=''>	mov dword [os_NetIOBaseMem], eax</p><p id='925' class=''></p><p id='926' class=''>	; Grab the IRQ of the device</p><p id='927' class=''>	mov dl, 0x0F				; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)</p><p id='928' class=''>	call os_pci_read_reg</p><p id='929' class=''>	mov [os_NetIRQ], al			; AL holds the IRQ</p><p id='930' class=''></p><p id='931' class=''>	; Enable PCI Bus Mastering</p><p id='932' class=''>	mov dl, 0x01				; Get Status/Command</p><p id='933' class=''>	call os_pci_read_reg</p><p id='934' class=''>	bts eax, 2</p><p id='935' class=''>	call os_pci_write_reg</p><p id='936' class=''></p><p id='937' class=''>	; Grab the MAC address</p><p id='938' class=''>	mov rsi, [os_NetIOBaseMem]</p><p id='939' class=''>	mov eax, [rsi+0x5400]				; RAL</p><p id='940' class=''>	cmp eax, 0x00000000</p><p id='941' class=''>	je os_net_i8254x_init_get_MAC_via_EPROM</p><p id='942' class=''>	mov [os_NetMAC], al</p><p id='943' class=''>	shr eax, 8</p><p id='944' class=''>	mov [os_NetMAC+1], al</p><p id='945' class=''>	shr eax, 8</p><p id='946' class=''>	mov [os_NetMAC+2], al</p><p id='947' class=''>	shr eax, 8</p><p id='948' class=''>	mov [os_NetMAC+3], al</p><p id='949' class=''>	mov eax, [rsi+0x5404]				; RAH</p><p id='950' class=''>	mov [os_NetMAC+4], al</p><p id='951' class=''>	shr eax, 8</p><p id='952' class=''>	mov [os_NetMAC+5], al</p><p id='953' class=''>	jmp os_net_i8254x_init_done_MAC</p><p id='954' class=''></p><p id='955' class=''>os_net_i8254x_init_get_MAC_via_EPROM:</p><p id='956' class=''>	mov rsi, [os_NetIOBaseMem]</p><p id='957' class=''>	mov eax, 0x00000001</p><p id='958' class=''>	mov [rsi+0x14], eax</p><p id='959' class=''>	mov eax, [rsi+0x14]</p><p id='960' class=''>	shr eax, 16</p><p id='961' class=''>	mov [os_NetMAC], al</p><p id='962' class=''>	shr eax, 8</p><p id='963' class=''>	mov [os_NetMAC+1], al</p><p id='964' class=''>	mov eax, 0x00000101</p><p id='965' class=''>	mov [rsi+0x14], eax</p><p id='966' class=''>	mov eax, [rsi+0x14]</p><p id='967' class=''>	shr eax, 16</p><p id='968' class=''>	mov [os_NetMAC+2], al</p><p id='969' class=''>	shr eax, 8</p><p id='970' class=''>	mov [os_NetMAC+3], al</p><p id='971' class=''>	mov eax, 0x00000201</p><p id='972' class=''>	mov [rsi+0x14], eax</p><p id='973' class=''>	mov eax, [rsi+0x14]</p><p id='974' class=''>	shr eax, 16</p><p id='975' class=''>	mov [os_NetMAC+4], al</p><p id='976' class=''>	shr eax, 8</p><p id='977' class=''>	mov [os_NetMAC+5], al</p><p id='978' class=''>os_net_i8254x_init_done_MAC:</p><p id='979' class=''></p><p id='980' class=''>	; Reset the device</p><p id='981' class=''>	call os_net_i8254x_reset</p><p id='982' class=''></p><p id='983' class=''>	pop rax</p><p id='984' class=''>	pop rcx</p><p id='985' class=''>	pop rdx</p><p id='986' class=''>	pop rsi</p><p id='987' class=''>	ret</p><p id='988' class=''>; -----------------------------------------------------------------------------</p><p id='989' class=''></p><p id='990' class=''></p><p id='991' class=''>; -----------------------------------------------------------------------------</p><p id='992' class=''>; os_net_i8254x_reset - Reset an Intel 8254x NIC</p><p id='993' class=''>;  IN:	Nothing</p><p id='994' class=''>; OUT:	Nothing, all registers preserved</p><p id='995' class=''>os_net_i8254x_reset:</p><p id='996' class=''>	mov rsi, [os_NetIOBaseMem]</p><p id='997' class=''>	mov rdi, rsi</p><p id='998' class=''></p><p id='999' class=''>	mov eax, 0xFFFFFFFF</p><p id='1000' class=''>	mov [rsi+I8254X_REG_IMC], eax		; Disable all interrupt causes</p><p id='1001' class=''>	mov eax, [rsi+I8254X_REG_ICR]		; Clear any pending interrupts</p><p id='1002' class=''>	xor eax, eax</p><p id='1003' class=''>	mov [rsi+I8254X_REG_ITR], eax		; Disable interrupt throttling logic</p><p id='1004' class=''></p><p id='1005' class=''>	mov eax, 0x00000030</p><p id='1006' class=''>	mov [rsi+I8254X_REG_PBA], eax		; PBA: set the RX buffer size to 48KB (TX buffer is calculated as 64-RX buffer)</p><p id='1007' class=''></p><p id='1008' class=''>	mov eax, 0x80008060</p><p id='1009' class=''>	mov [rsi+I8254X_REG_TXCW], eax		; TXCW: set ANE, TxConfigWord (Half/Full duplex, Next Page Request)</p><p id='1010' class=''></p><p id='1011' class=''>	mov eax, [rsi+I8254X_REG_CTRL]</p><p id='1012' class=''>	btr eax, 3</p><p id='1013' class=''>	bts eax, 6</p><p id='1014' class=''>	bts eax, 5</p><p id='1015' class=''>	btr eax, 31</p><p id='1016' class=''>	btr eax, 30</p><p id='1017' class=''>	btr eax, 7</p><p id='1018' class=''>	mov [rsi+I8254X_REG_CTRL], eax		; CTRL: clear LRST, set SLU and ASDE, clear RSTPHY, VME, and ILOS</p><p id='1019' class=''></p><p id='1020' class=''>	push rdi</p><p id='1021' class=''>	add rdi, 0x5200				; MTA: reset</p><p id='1022' class=''>	mov eax, 0xFFFFFFFF</p><p id='1023' class=''>	stosd</p><p id='1024' class=''>	stosd</p><p id='1025' class=''>	stosd</p><p id='1026' class=''>	stosd</p><p id='1027' class=''>	pop rdi</p><p id='1028' class=''></p><p id='1029' class=''>	mov rax, os_eth_rx_buffer</p><p id='1030' class=''>	mov [rsi+I8254X_REG_RDBAL], eax		; Receive Descriptor Base Address Low</p><p id='1031' class=''>	shr rax, 32</p><p id='1032' class=''>	mov [rsi+I8254X_REG_RDBAH], eax		; Receive Descriptor Base Address High</p><p id='1033' class=''>	mov eax, (32 * 16)</p><p id='1034' class=''>	mov [rsi+I8254X_REG_RDLEN], eax		; Receive Descriptor Length</p><p id='1035' class=''>	xor eax, eax</p><p id='1036' class=''>	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head</p><p id='1037' class=''>	mov eax, 1</p><p id='1038' class=''>	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail</p><p id='1039' class=''>	mov eax, 0x04008006			; Receiver Enable, Store Bad Packets, Broadcast Accept Mode, Strip Ethernet CRC from incoming packet</p><p id='1040' class=''>	mov [rsi+I8254X_REG_RCTL], eax		; Receive Control Register</p><p id='1041' class=''></p><p id='1042' class=''>	push rdi</p><p id='1043' class=''>	mov rdi, os_eth_rx_buffer</p><p id='1044' class=''>	mov rax, 0x1c9000</p><p id='1045' class=''>	stosd</p><p id='1046' class=''>	pop rdi</p><p id='1047' class=''></p><p id='1048' class=''>	mov rax, os_eth_tx_buffer</p><p id='1049' class=''>	mov [rsi+I8254X_REG_TDBAL], eax		; Transmit Descriptor Base Address Low</p><p id='1050' class=''>	shr rax, 32</p><p id='1051' class=''>	mov [rsi+I8254X_REG_TDBAH], eax		; Transmit Descriptor Base Address High</p><p id='1052' class=''>	mov eax, (32 * 16)</p><p id='1053' class=''>	mov [rsi+I8254X_REG_TDLEN], eax		; Transmit Descriptor Length</p><p id='1054' class=''>	xor eax, eax</p><p id='1055' class=''>	mov [rsi+I8254X_REG_TDH], eax		; Transmit Descriptor Head</p><p id='1056' class=''>	mov [rsi+I8254X_REG_TDT], eax		; Transmit Descriptor Tail</p><p id='1057' class=''>	mov eax, 0x010400FA			; Enabled, Pad Short Packets, 15 retries, 64-byte COLD, Re-transmit on Late Collision</p><p id='1058' class=''>	mov [rsi+I8254X_REG_TCTL], eax		; Transmit Control Register</p><p id='1059' class=''>	mov eax, 0x0060200A			; IPGT 10, IPGR1 8, IPGR2 6</p><p id='1060' class=''>	mov [rsi+I8254X_REG_TIPG], eax		; Transmit IPG Register</p><p id='1061' class=''></p><p id='1062' class=''>	xor eax, eax</p><p id='1063' class=''>	mov [rsi+I8254X_REG_RDTR], eax		; Clear the Receive Delay Timer Register</p><p id='1064' class=''>	mov [rsi+I8254X_REG_RADV], eax		; Clear the Receive Interrupt Absolute Delay Timer</p><p id='1065' class=''>	mov [rsi+I8254X_REG_RSRPD], eax		; Clear the Receive Small Packet Detect Interrupt</p><p id='1066' class=''>	bts eax, 0				; TXDW</p><p id='1067' class=''>	bts eax, 7				; RXT0</p><p id='1068' class=''>	mov eax, 0x1FFFF			; Temp enable all interrupt types</p><p id='1069' class=''>	mov [rsi+I8254X_REG_IMS], eax		; Enable interrupt types</p><p id='1070' class=''></p><p id='1071' class=''>	ret</p><p id='1072' class=''>; -----------------------------------------------------------------------------</p><p id='1073' class=''></p><p id='1074' class=''></p><p id='1075' class=''>; -----------------------------------------------------------------------------</p><p id='1076' class=''>; os_net_i8254x_transmit - Transmit a packet via an Intel 8254x NIC</p><p id='1077' class=''>;  IN:	RSI = Location of packet</p><p id='1078' class=''>;	RCX = Length of packet</p><p id='1079' class=''>; OUT:	Nothing</p><p id='1080' class=''>;	Uses RAX, RCX, RSI, RDI</p><p id='1081' class=''>os_net_i8254x_transmit:</p><p id='1082' class=''>	mov rdi, os_eth_tx_buffer		; Transmit Descriptor Base Address</p><p id='1083' class=''>	mov rax, rsi</p><p id='1084' class=''>	stosq					; Store the data location</p><p id='1085' class=''>	mov rax, rcx				; The packet size is in CX</p><p id='1086' class=''>	bts rax, 24				; EOP</p><p id='1087' class=''>	bts rax, 25				; IFCS</p><p id='1088' class=''>	bts rax, 27				; RS</p><p id='1089' class=''>	stosq</p><p id='1090' class=''>	mov rdi, [os_NetIOBaseMem]</p><p id='1091' class=''>	xor eax, eax</p><p id='1092' class=''>	mov [rdi+I8254X_REG_TDH], eax		; TDH - Transmit Descriptor Head</p><p id='1093' class=''>	add eax, 1</p><p id='1094' class=''>	mov [rdi+I8254X_REG_TDT], eax		; TDL - Transmit Descriptor Tail</p><p id='1095' class=''>	ret</p><p id='1096' class=''>; -----------------------------------------------------------------------------</p><p id='1097' class=''></p><p id='1098' class=''></p><p id='1099' class=''>; -----------------------------------------------------------------------------</p><p id='1100' class=''>; os_net_i8254x_poll - Polls the Intel 8254x NIC for a received packet</p><p id='1101' class=''>;  IN:	RDI = Location to store packet</p><p id='1102' class=''>; OUT:	RCX = Length of packet</p><p id='1103' class=''>;	Uses RAX, RCX, RDX, RSI, RDI</p><p id='1104' class=''>os_net_i8254x_poll:</p><p id='1105' class=''>	xor ecx, ecx</p><p id='1106' class=''></p><p id='1107' class=''>	mov cx, [os_eth_rx_buffer+8]		; Get the packet length</p><p id='1108' class=''>	mov rsi, 0x1c9000</p><p id='1109' class=''>	push rcx</p><p id='1110' class=''>	rep movsb</p><p id='1111' class=''>	pop rcx</p><p id='1112' class=''>	mov rsi, [os_NetIOBaseMem]</p><p id='1113' class=''>	xor eax, eax</p><p id='1114' class=''>	mov [rsi+I8254X_REG_RDH], eax		; Receive Descriptor Head</p><p id='1115' class=''>	mov eax, 1</p><p id='1116' class=''>	mov [rsi+I8254X_REG_RDT], eax		; Receive Descriptor Tail</p><p id='1117' class=''></p><p id='1118' class=''>	push rdi</p><p id='1119' class=''>	mov rdi, os_eth_rx_buffer</p><p id='1120' class=''>	mov rax, 0x1c9000</p><p id='1121' class=''>	stosd</p><p id='1122' class=''>	pop rdi</p><p id='1123' class=''></p><p id='1124' class=''>	ret</p><p id='1125' class=''>; -----------------------------------------------------------------------------</p><p id='1126' class=''></p><p id='1127' class=''></p><p id='1128' class=''>; -----------------------------------------------------------------------------</p><p id='1129' class=''>; os_net_i8254x_ack_int - Acknowledge an internal interrupt of the Intel 8254x NIC</p><p id='1130' class=''>;  IN:	Nothing</p><p id='1131' class=''>; OUT:	RAX = Ethernet status</p><p id='1132' class=''>;	Uses RDI</p><p id='1133' class=''>os_net_i8254x_ack_int:</p><p id='1134' class=''>	push rdi</p><p id='1135' class=''>	xor eax, eax</p><p id='1136' class=''>	mov rdi, [os_NetIOBaseMem]</p><p id='1137' class=''>	mov eax, [rdi+I8254X_REG_ICR]</p><p id='1138' class=''>	pop rdi</p><p id='1139' class=''>	ret</p><p id='1140' class=''>; -----------------------------------------------------------------------------</p><p id='1141' class=''></p><p id='1142' class=''></p><p id='1143' class=''>; Maximum packet size</p><p id='1144' class=''>I8254X_MAX_PKT_SIZE	equ 16384</p><p id='1145' class=''></p><p id='1146' class=''>; Register list</p><p id='1147' class=''>I8254X_REG_CTRL		equ 0x0000 ; Control Register</p><p id='1148' class=''>I8254X_REG_STATUS	equ 0x0008 ; Device Status Register</p><p id='1149' class=''>I8254X_REG_CTRLEXT	equ 0x0018 ; Extended Control Register</p><p id='1150' class=''>I8254X_REG_MDIC		equ 0x0020 ; MDI Control Register</p><p id='1151' class=''>I8254X_REG_FCAL		equ 0x0028 ; Flow Control Address Low</p><p id='1152' class=''>I8254X_REG_FCAH		equ 0x002C ; Flow Control Address High</p><p id='1153' class=''>I8254X_REG_FCT		equ 0x0030 ; Flow Control Type</p><p id='1154' class=''>I8254X_REG_VET		equ 0x0038 ; VLAN Ether Type</p><p id='1155' class=''>I8254X_REG_ICR		equ 0x00C0 ; Interrupt Cause Read</p><p id='1156' class=''>I8254X_REG_ITR		equ 0x00C4 ; Interrupt Throttling Register</p><p id='1157' class=''>I8254X_REG_ICS		equ 0x00C8 ; Interrupt Cause Set Register</p><p id='1158' class=''>I8254X_REG_IMS		equ 0x00D0 ; Interrupt Mask Set/Read Register</p><p id='1159' class=''>I8254X_REG_IMC		equ 0x00D8 ; Interrupt Mask Clear Register</p><p id='1160' class=''>I8254X_REG_RCTL		equ 0x0100 ; Receive Control Register</p><p id='1161' class=''>I8254X_REG_FCTTV	equ 0x0170 ; Flow Control Transmit Timer Value</p><p id='1162' class=''>I8254X_REG_TXCW		equ 0x0178 ; Transmit Configuration Word</p><p id='1163' class=''>I8254X_REG_RXCW		equ 0x0180 ; Receive Configuration Word</p><p id='1164' class=''>I8254X_REG_TCTL		equ 0x0400 ; Transmit Control Register</p><p id='1165' class=''>I8254X_REG_TIPG		equ 0x0410 ; Transmit Inter Packet Gap</p><p id='1166' class=''></p><p id='1167' class=''>I8254X_REG_LEDCTL	equ 0x0E00 ; LED Control</p><p id='1168' class=''>I8254X_REG_PBA		equ 0x1000 ; Packet Buffer Allocation</p><p id='1169' class=''></p><p id='1170' class=''>I8254X_REG_RDBAL	equ 0x2800 ; RX Descriptor Base Address Low</p><p id='1171' class=''>I8254X_REG_RDBAH	equ 0x2804 ; RX Descriptor Base Address High</p><p id='1172' class=''>I8254X_REG_RDLEN	equ 0x2808 ; RX Descriptor Length</p><p id='1173' class=''>I8254X_REG_RDH		equ 0x2810 ; RX Descriptor Head</p><p id='1174' class=''>I8254X_REG_RDT		equ 0x2818 ; RX Descriptor Tail</p><p id='1175' class=''>I8254X_REG_RDTR		equ 0x2820 ; RX Delay Timer Register</p><p id='1176' class=''>I8254X_REG_RXDCTL	equ 0x3828 ; RX Descriptor Control</p><p id='1177' class=''>I8254X_REG_RADV		equ 0x282C ; RX Int. Absolute Delay Timer</p><p id='1178' class=''>I8254X_REG_RSRPD	equ 0x2C00 ; RX Small Packet Detect Interrupt</p><p id='1179' class=''></p><p id='1180' class=''>I8254X_REG_TXDMAC	equ 0x3000 ; TX DMA Control</p><p id='1181' class=''>I8254X_REG_TDBAL	equ 0x3800 ; TX Descriptor Base Address Low</p><p id='1182' class=''>I8254X_REG_TDBAH	equ 0x3804 ; TX Descriptor Base Address High</p><p id='1183' class=''>I8254X_REG_TDLEN	equ 0x3808 ; TX Descriptor Length</p><p id='1184' class=''>I8254X_REG_TDH		equ 0x3810 ; TX Descriptor Head</p><p id='1185' class=''>I8254X_REG_TDT		equ 0x3818 ; TX Descriptor Tail</p><p id='1186' class=''>I8254X_REG_TIDV		equ 0x3820 ; TX Interrupt Delay Value</p><p id='1187' class=''>I8254X_REG_TXDCTL	equ 0x3828 ; TX Descriptor Control</p><p id='1188' class=''>I8254X_REG_TADV		equ 0x382C ; TX Absolute Interrupt Delay Value</p><p id='1189' class=''>I8254X_REG_TSPMT	equ 0x3830 ; TCP Segmentation Pad & Min Threshold</p><p id='1190' class=''></p><p id='1191' class=''>I8254X_REG_RXCSUM	equ 0x5000 ; RX Checksum Control</p><p id='1192' class=''></p><p id='1193' class=''>; Register list for i8254x</p><p id='1194' class=''>I82542_REG_RDTR		equ 0x0108 ; RX Delay Timer Register</p><p id='1195' class=''>I82542_REG_RDBAL	equ 0x0110 ; RX Descriptor Base Address Low</p><p id='1196' class=''>I82542_REG_RDBAH	equ 0x0114 ; RX Descriptor Base Address High</p><p id='1197' class=''>I82542_REG_RDLEN	equ 0x0118 ; RX Descriptor Length</p><p id='1198' class=''>I82542_REG_RDH		equ 0x0120 ; RDH for i82542</p><p id='1199' class=''>I82542_REG_RDT		equ 0x0128 ; RDT for i82542</p><p id='1200' class=''>I82542_REG_TDBAL	equ 0x0420 ; TX Descriptor Base Address Low</p><p id='1201' class=''>I82542_REG_TDBAH	equ 0x0424 ; TX Descriptor Base Address Low</p><p id='1202' class=''>I82542_REG_TDLEN	equ 0x0428 ; TX Descriptor Length</p><p id='1203' class=''>I82542_REG_TDH		equ 0x0430 ; TDH for i82542</p><p id='1204' class=''>I82542_REG_TDT		equ 0x0438 ; TDT for i82542</p><p id='1205' class=''></p><p id='1206' class=''>; CTRL - Control Register (0x0000)</p><p id='1207' class=''>I8254X_CTRL_FD		equ 0x00000001 ; Full Duplex</p><p id='1208' class=''>I8254X_CTRL_LRST	equ 0x00000008 ; Link Reset</p><p id='1209' class=''>I8254X_CTRL_ASDE	equ 0x00000020 ; Auto-speed detection</p><p id='1210' class=''>I8254X_CTRL_SLU		equ 0x00000040 ; Set Link Up</p><p id='1211' class=''>I8254X_CTRL_ILOS	equ 0x00000080 ; Invert Loss of Signal</p><p id='1212' class=''>I8254X_CTRL_SPEED_MASK	equ 0x00000300 ; Speed selection</p><p id='1213' class=''>I8254X_CTRL_SPEED_SHIFT	equ 8</p><p id='1214' class=''>I8254X_CTRL_FRCSPD	equ 0x00000800 ; Force Speed</p><p id='1215' class=''>I8254X_CTRL_FRCDPLX	equ 0x00001000 ; Force Duplex</p><p id='1216' class=''>I8254X_CTRL_SDP0_DATA	equ 0x00040000 ; SDP0 data</p><p id='1217' class=''>I8254X_CTRL_SDP1_DATA	equ 0x00080000 ; SDP1 data</p><p id='1218' class=''>I8254X_CTRL_SDP0_IODIR	equ 0x00400000 ; SDP0 direction</p><p id='1219' class=''>I8254X_CTRL_SDP1_IODIR	equ 0x00800000 ; SDP1 direction</p><p id='1220' class=''>I8254X_CTRL_RST		equ 0x04000000 ; Device Reset</p><p id='1221' class=''>I8254X_CTRL_RFCE	equ 0x08000000 ; RX Flow Ctrl Enable</p><p id='1222' class=''>I8254X_CTRL_TFCE	equ 0x10000000 ; TX Flow Ctrl Enable</p><p id='1223' class=''>I8254X_CTRL_VME		equ 0x40000000 ; VLAN Mode Enable</p><p id='1224' class=''>I8254X_CTRL_PHY_RST	equ 0x80000000 ; PHY reset</p><p id='1225' class=''></p><p id='1226' class=''>; STATUS - Device Status Register (0x0008)</p><p id='1227' class=''>I8254X_STATUS_FD		equ 0x00000001 ; Full Duplex</p><p id='1228' class=''>I8254X_STATUS_LU		equ 0x00000002 ; Link Up</p><p id='1229' class=''>I8254X_STATUS_TXOFF		equ 0x00000010 ; Transmit paused</p><p id='1230' class=''>I8254X_STATUS_TBIMODE		equ 0x00000020 ; TBI Mode</p><p id='1231' class=''>I8254X_STATUS_SPEED_MASK	equ 0x000000C0 ; Link Speed setting</p><p id='1232' class=''>I8254X_STATUS_SPEED_SHIFT	equ 6</p><p id='1233' class=''>I8254X_STATUS_ASDV_MASK		equ 0x00000300 ; Auto Speed Detection</p><p id='1234' class=''>I8254X_STATUS_ASDV_SHIFT	equ 8</p><p id='1235' class=''>I8254X_STATUS_PCI66		equ 0x00000800 ; PCI bus speed</p><p id='1236' class=''>I8254X_STATUS_BUS64		equ 0x00001000 ; PCI bus width</p><p id='1237' class=''>I8254X_STATUS_PCIX_MODE		equ 0x00002000 ; PCI-X mode</p><p id='1238' class=''>I8254X_STATUS_PCIXSPD_MASK	equ 0x0000C000 ; PCI-X speed</p><p id='1239' class=''>I8254X_STATUS_PCIXSPD_SHIFT	equ 14</p><p id='1240' class=''></p><p id='1241' class=''>; CTRL_EXT - Extended Device Control Register (0x0018)</p><p id='1242' class=''>I8254X_CTRLEXT_PHY_INT		equ 0x00000020 ; PHY interrupt</p><p id='1243' class=''>I8254X_CTRLEXT_SDP6_DATA	equ 0x00000040 ; SDP6 data</p><p id='1244' class=''>I8254X_CTRLEXT_SDP7_DATA	equ 0x00000080 ; SDP7 data</p><p id='1245' class=''>I8254X_CTRLEXT_SDP6_IODIR	equ 0x00000400 ; SDP6 direction</p><p id='1246' class=''>I8254X_CTRLEXT_SDP7_IODIR	equ 0x00000800 ; SDP7 direction</p><p id='1247' class=''>I8254X_CTRLEXT_ASDCHK		equ 0x00001000 ; Auto-Speed Detect Chk</p><p id='1248' class=''>I8254X_CTRLEXT_EE_RST		equ 0x00002000 ; EEPROM reset</p><p id='1249' class=''>I8254X_CTRLEXT_SPD_BYPS		equ 0x00008000 ; Speed Select Bypass</p><p id='1250' class=''>I8254X_CTRLEXT_RO_DIS		equ 0x00020000 ; Relaxed Ordering Dis.</p><p id='1251' class=''>I8254X_CTRLEXT_LNKMOD_MASK	equ 0x00C00000 ; Link Mode</p><p id='1252' class=''>I8254X_CTRLEXT_LNKMOD_SHIFT	equ 22</p><p id='1253' class=''></p><p id='1254' class=''>; MDIC - MDI Control Register (0x0020)</p><p id='1255' class=''>I8254X_MDIC_DATA_MASK	equ 0x0000FFFF ; Data</p><p id='1256' class=''>I8254X_MDIC_REG_MASK	equ 0x001F0000 ; PHY Register</p><p id='1257' class=''>I8254X_MDIC_REG_SHIFT	equ 16</p><p id='1258' class=''>I8254X_MDIC_PHY_MASK	equ 0x03E00000 ; PHY Address</p><p id='1259' class=''>I8254X_MDIC_PHY_SHIFT	equ 21</p><p id='1260' class=''>I8254X_MDIC_OP_MASK	equ 0x0C000000 ; Opcode</p><p id='1261' class=''>I8254X_MDIC_OP_SHIFT	equ 26</p><p id='1262' class=''>I8254X_MDIC_R		equ 0x10000000 ; Ready</p><p id='1263' class=''>I8254X_MDIC_I		equ 0x20000000 ; Interrupt Enable</p><p id='1264' class=''>I8254X_MDIC_E		equ 0x40000000 ; Error</p><p id='1265' class=''></p><p id='1266' class=''>; ICR - Interrupt Cause Read (0x00c0)</p><p id='1267' class=''>I8254X_ICR_TXDW		equ 0x00000001 ; TX Desc Written back</p><p id='1268' class=''>I8254X_ICR_TXQE		equ 0x00000002 ; TX Queue Empty</p><p id='1269' class=''>I8254X_ICR_LSC		equ 0x00000004 ; Link Status Change</p><p id='1270' class=''>I8254X_ICR_RXSEQ	equ 0x00000008 ; RX Sequence Error</p><p id='1271' class=''>I8254X_ICR_RXDMT0	equ 0x00000010 ; RX Desc min threshold reached</p><p id='1272' class=''>I8254X_ICR_RXO		equ 0x00000040 ; RX Overrun</p><p id='1273' class=''>I8254X_ICR_RXT0		equ 0x00000080 ; RX Timer Interrupt</p><p id='1274' class=''>I8254X_ICR_MDAC		equ 0x00000200 ; MDIO Access Complete</p><p id='1275' class=''>I8254X_ICR_RXCFG	equ 0x00000400</p><p id='1276' class=''>I8254X_ICR_PHY_INT	equ 0x00001000 ; PHY Interrupt</p><p id='1277' class=''>I8254X_ICR_GPI_SDP6	equ 0x00002000 ; GPI on SDP6</p><p id='1278' class=''>I8254X_ICR_GPI_SDP7	equ 0x00004000 ; GPI on SDP7</p><p id='1279' class=''>I8254X_ICR_TXD_LOW	equ 0x00008000 ; TX Desc low threshold hit</p><p id='1280' class=''>I8254X_ICR_SRPD		equ 0x00010000 ; Small RX packet detected</p><p id='1281' class=''></p><p id='1282' class=''>; RCTL - Receive Control Register (0x0100)</p><p id='1283' class=''>I8254X_RCTL_EN		equ 0x00000002 ; Receiver Enable</p><p id='1284' class=''>I8254X_RCTL_SBP		equ 0x00000004 ; Store Bad Packets</p><p id='1285' class=''>I8254X_RCTL_UPE		equ 0x00000008 ; Unicast Promiscuous Enabled</p><p id='1286' class=''>I8254X_RCTL_MPE		equ 0x00000010 ; Xcast Promiscuous Enabled</p><p id='1287' class=''>I8254X_RCTL_LPE		equ 0x00000020 ; Long Packet Reception Enable</p><p id='1288' class=''>I8254X_RCTL_LBM_MASK	equ 0x000000C0 ; Loopback Mode</p><p id='1289' class=''>I8254X_RCTL_LBM_SHIFT	equ 6</p><p id='1290' class=''>I8254X_RCTL_RDMTS_MASK	equ 0x00000300 ; RX Desc Min Threshold Size</p><p id='1291' class=''>I8254X_RCTL_RDMTS_SHIFT	equ 8</p><p id='1292' class=''>I8254X_RCTL_MO_MASK	equ 0x00003000 ; Multicast Offset</p><p id='1293' class=''>I8254X_RCTL_MO_SHIFT	equ 12</p><p id='1294' class=''>I8254X_RCTL_BAM		equ 0x00008000 ; Broadcast Accept Mode</p><p id='1295' class=''>I8254X_RCTL_BSIZE_MASK	equ 0x00030000 ; RX Buffer Size</p><p id='1296' class=''>I8254X_RCTL_BSIZE_SHIFT	equ 16</p><p id='1297' class=''>I8254X_RCTL_VFE		equ 0x00040000 ; VLAN Filter Enable</p><p id='1298' class=''>I8254X_RCTL_CFIEN	equ 0x00080000 ; CFI Enable</p><p id='1299' class=''>I8254X_RCTL_CFI		equ 0x00100000 ; Canonical Form Indicator Bit</p><p id='1300' class=''>I8254X_RCTL_DPF		equ 0x00400000 ; Discard Pause Frames</p><p id='1301' class=''>I8254X_RCTL_PMCF	equ 0x00800000 ; Pass MAC Control Frames</p><p id='1302' class=''>I8254X_RCTL_BSEX	equ 0x02000000 ; Buffer Size Extension</p><p id='1303' class=''>I8254X_RCTL_SECRC	equ 0x04000000 ; Strip Ethernet CRC</p><p id='1304' class=''></p><p id='1305' class=''>; TCTL - Transmit Control Register (0x0400)</p><p id='1306' class=''>I8254X_TCTL_EN		equ 0x00000002 ; Transmit Enable</p><p id='1307' class=''>I8254X_TCTL_PSP		equ 0x00000008 ; Pad short packets</p><p id='1308' class=''>I8254X_TCTL_SWXOFF	equ 0x00400000 ; Software XOFF Transmission</p><p id='1309' class=''></p><p id='1310' class=''>; PBA - Packet Buffer Allocation (0x1000)</p><p id='1311' class=''>I8254X_PBA_RXA_MASK	equ 0x0000FFFF ; RX Packet Buffer</p><p id='1312' class=''>I8254X_PBA_RXA_SHIFT	equ 0</p><p id='1313' class=''>I8254X_PBA_TXA_MASK	equ 0xFFFF0000 ; TX Packet Buffer</p><p id='1314' class=''>I8254X_PBA_TXA_SHIFT	equ 16</p><p id='1315' class=''></p><p id='1316' class=''>; Flow Control Type</p><p id='1317' class=''>I8254X_FCT_TYPE_DEFAULT	equ 0x8808</p><p id='1318' class=''></p><p id='1319' class=''>; === TX Descriptor fields ===</p><p id='1320' class=''></p><p id='1321' class=''>; TX Packet Length (word 2)</p><p id='1322' class=''>I8254X_TXDESC_LEN_MASK	equ 0x0000ffff</p><p id='1323' class=''></p><p id='1324' class=''>; TX Descriptor CMD field (word 2)</p><p id='1325' class=''>I8254X_TXDESC_IDE	equ 0x80000000 ; Interrupt Delay Enable</p><p id='1326' class=''>I8254X_TXDESC_VLE	equ 0x40000000 ; VLAN Packet Enable</p><p id='1327' class=''>I8254X_TXDESC_DEXT	equ 0x20000000 ; Extension</p><p id='1328' class=''>I8254X_TXDESC_RPS	equ 0x10000000 ; Report Packet Sent</p><p id='1329' class=''>I8254X_TXDESC_RS	equ 0x08000000 ; Report Status</p><p id='1330' class=''>I8254X_TXDESC_IC	equ 0x04000000 ; Insert Checksum</p><p id='1331' class=''>I8254X_TXDESC_IFCS	equ 0x02000000 ; Insert FCS</p><p id='1332' class=''>I8254X_TXDESC_EOP	equ 0x01000000 ; End Of Packet</p><p id='1333' class=''></p><p id='1334' class=''>; TX Descriptor STA field (word 3)</p><p id='1335' class=''>I8254X_TXDESC_TU	equ 0x00000008 ; Transmit Underrun</p><p id='1336' class=''>I8254X_TXDESC_LC	equ 0x00000004 ; Late Collision</p><p id='1337' class=''>I8254X_TXDESC_EC	equ 0x00000002 ; Excess Collisions</p><p id='1338' class=''>I8254X_TXDESC_DD	equ 0x00000001 ; Descriptor Done</p><p id='1339' class=''></p><p id='1340' class=''>; === RX Descriptor fields ===</p><p id='1341' class=''></p><p id='1342' class=''>; RX Packet Length (word 2)</p><p id='1343' class=''>I8254X_RXDESC_LEN_MASK	equ 0x0000ffff</p><p id='1344' class=''></p><p id='1345' class=''>; RX Descriptor STA field (word 3)</p><p id='1346' class=''>I8254X_RXDESC_PIF	equ 0x00000080 ; Passed In-exact Filter</p><p id='1347' class=''>I8254X_RXDESC_IPCS	equ 0x00000040 ; IP cksum calculated</p><p id='1348' class=''>I8254X_RXDESC_TCPCS	equ 0x00000020 ; TCP cksum calculated</p><p id='1349' class=''>I8254X_RXDESC_VP	equ 0x00000008 ; Packet is 802.1Q</p><p id='1350' class=''>I8254X_RXDESC_IXSM	equ 0x00000004 ; Ignore cksum indication</p><p id='1351' class=''>I8254X_RXDESC_EOP	equ 0x00000002 ; End Of Packet</p><p id='1352' class=''>I8254X_RXDESC_DD	equ 0x00000001 ; Descriptor Done</p><p id='1353' class=''></p><p id='1354' class=''>; =============================================================================</p><p id='1355' class=''>; EOHEF</p><p id='1356' class=''>; =============================================================================</p><p id='1357' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='1358' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='1359' class=''>;</p><p id='1360' class=''>; Realtek 8169 NIC. http://wiki.osdev.org/RTL8169</p><p id='1361' class=''>; =============================================================================</p><p id='1362' class=''></p><p id='1363' class=''>align 16</p><p id='1364' class=''>db 'DEBUG: RTL8169  '</p><p id='1365' class=''>align 16</p><p id='1366' class=''></p><p id='1367' class=''></p><p id='1368' class=''>; -----------------------------------------------------------------------------</p><p id='1369' class=''>; Initialize a Realtek 8169 NIC</p><p id='1370' class=''>;  IN:	BL  = Bus number of the Realtek device</p><p id='1371' class=''>;	CL  = Device/Slot number of the Realtek device</p><p id='1372' class=''>os_net_rtl8169_init:</p><p id='1373' class=''>	push rsi</p><p id='1374' class=''>	push rdx</p><p id='1375' class=''>	push rcx</p><p id='1376' class=''>	push rax</p><p id='1377' class=''></p><p id='1378' class=''>	; Grab the Base I/O Address of the device</p><p id='1379' class=''>	mov dl, 0x04				; BAR0</p><p id='1380' class=''>	call os_pci_read_reg</p><p id='1381' class=''>	and eax, 0xFFFFFFFC			; EAX now holds the Base IO Address (clear the low 2 bits)</p><p id='1382' class=''>	mov word [os_NetIOAddress], ax</p><p id='1383' class=''></p><p id='1384' class=''>	; Grab the IRQ of the device</p><p id='1385' class=''>	mov dl, 0x0F				; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)</p><p id='1386' class=''>	call os_pci_read_reg</p><p id='1387' class=''>	mov [os_NetIRQ], al			; AL holds the IRQ</p><p id='1388' class=''></p><p id='1389' class=''>	; Grab the MAC address</p><p id='1390' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1391' class=''>	in al, dx</p><p id='1392' class=''>	mov [os_NetMAC], al</p><p id='1393' class=''>	add dx, 1</p><p id='1394' class=''>	in al, dx</p><p id='1395' class=''>	mov [os_NetMAC+1], al</p><p id='1396' class=''>	add dx, 1</p><p id='1397' class=''>	in al, dx</p><p id='1398' class=''>	mov [os_NetMAC+2], al</p><p id='1399' class=''>	add dx, 1</p><p id='1400' class=''>	in al, dx</p><p id='1401' class=''>	mov [os_NetMAC+3], al</p><p id='1402' class=''>	add dx, 1</p><p id='1403' class=''>	in al, dx</p><p id='1404' class=''>	mov [os_NetMAC+4], al</p><p id='1405' class=''>	add dx, 1</p><p id='1406' class=''>	in al, dx</p><p id='1407' class=''>	mov [os_NetMAC+5], al</p><p id='1408' class=''></p><p id='1409' class=''>	; Reset the device</p><p id='1410' class=''>	call os_net_rtl8169_reset</p><p id='1411' class=''></p><p id='1412' class=''>	pop rax</p><p id='1413' class=''>	pop rcx</p><p id='1414' class=''>	pop rdx</p><p id='1415' class=''>	pop rsi</p><p id='1416' class=''>	ret</p><p id='1417' class=''>; -----------------------------------------------------------------------------</p><p id='1418' class=''></p><p id='1419' class=''></p><p id='1420' class=''>; -----------------------------------------------------------------------------</p><p id='1421' class=''>; os_net_rtl8136_reset - Reset a Realtek 8169 NIC</p><p id='1422' class=''>;  IN:	Nothing</p><p id='1423' class=''>; OUT:	Nothing, all registers preserved</p><p id='1424' class=''>os_net_rtl8169_reset:</p><p id='1425' class=''>	push rdx</p><p id='1426' class=''>	push rcx</p><p id='1427' class=''>	push rax</p><p id='1428' class=''></p><p id='1429' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1430' class=''>	add dx, RTL8169_REG_COMMAND</p><p id='1431' class=''>	mov al, 0x10				; Bit 4 set for Reset</p><p id='1432' class=''>	out dx, al</p><p id='1433' class=''>	mov cx, 1000				; Wait no longer for the reset to complete</p><p id='1434' class=''>wait_for_8169_reset:</p><p id='1435' class=''>	in al, dx</p><p id='1436' class=''>	test al, 0x10</p><p id='1437' class=''>	jz reset_8169_completed			; RST remains 1 during reset, Reset complete when 0</p><p id='1438' class=''>	dec cx</p><p id='1439' class=''>	jns wait_for_8169_reset</p><p id='1440' class=''>reset_8169_completed:</p><p id='1441' class=''></p><p id='1442' class=''>	; Unlock config registers</p><p id='1443' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1444' class=''>	add dx, RTL8169_REG_9346CR</p><p id='1445' class=''>	mov al, 0xC0				; Unlock</p><p id='1446' class=''>	out dx, al</p><p id='1447' class=''></p><p id='1448' class=''>	; Set the C+ Command</p><p id='1449' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1450' class=''>	add dx, RTL8169_REG_CCR</p><p id='1451' class=''>	in ax, dx</p><p id='1452' class=''>	bts ax, 3				; Enable PCI Multiple Read/Write</p><p id='1453' class=''>	btc ax, 9				; Little-endian mode</p><p id='1454' class=''>	out dx, ax</p><p id='1455' class=''></p><p id='1456' class=''>	; Power management?</p><p id='1457' class=''></p><p id='1458' class=''>	; Recieve configuration</p><p id='1459' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1460' class=''>	add edx, RTL8169_REG_RCR</p><p id='1461' class=''>	mov eax, 0x0000E70A			; Set bits 1 (APM), 3 (AB), 8-10 (Unlimited), 13-15 (No limit)</p><p id='1462' class=''>	out dx, eax</p><p id='1463' class=''></p><p id='1464' class=''>	; Set up TCR</p><p id='1465' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1466' class=''>	add dx, RTL8169_REG_TCR</p><p id='1467' class=''>	mov eax, 0x03000700</p><p id='1468' class=''>	out dx, eax</p><p id='1469' class=''></p><p id='1470' class=''>	; Setup max RX size</p><p id='1471' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1472' class=''>	add dx, RTL8169_REG_MAXRX</p><p id='1473' class=''>	mov ax, 0x3FFF				; 16384 - 1</p><p id='1474' class=''>	out dx, ax</p><p id='1475' class=''></p><p id='1476' class=''>	; Setup max TX size</p><p id='1477' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1478' class=''>	add dx, RTL8169_REG_MAXTX</p><p id='1479' class=''>	mov al, 0x3B</p><p id='1480' class=''>	out dx, al</p><p id='1481' class=''></p><p id='1482' class=''>	; Set the Transmit Normal Priority Descriptor Start Address</p><p id='1483' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1484' class=''>	add dx, RTL8169_REG_TNPDS</p><p id='1485' class=''>	mov rax, os_eth_tx_buffer</p><p id='1486' class=''>	out dx, eax				; Write the low bits</p><p id='1487' class=''>	shr rax, 32</p><p id='1488' class=''>	add dx, 4</p><p id='1489' class=''>	out dx, eax				; Write the high bits</p><p id='1490' class=''>	mov eax, 0x70000000			; Set bit 30 (End of Descriptor Ring), 29 (FS), and 28 (LS)</p><p id='1491' class=''>	mov [os_eth_tx_buffer], eax</p><p id='1492' class=''></p><p id='1493' class=''>	; Set the Receive Descriptor Start Address</p><p id='1494' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1495' class=''>	add dx, RTL8169_REG_RDSAR</p><p id='1496' class=''>	mov rax, os_eth_rx_buffer</p><p id='1497' class=''>	out dx, eax				; Write the low bits</p><p id='1498' class=''>	shr rax, 32</p><p id='1499' class=''>	add dx, 4</p><p id='1500' class=''>	out dx, eax				; Write the high bits</p><p id='1501' class=''>	mov eax, 0x80001FF8			; Set bits 31 (Ownership), also buffer size (Max 0x1FF8)</p><p id='1502' class=''>	mov [os_eth_rx_buffer], eax</p><p id='1503' class=''>	mov rax, os_ethernet_rx_buffer</p><p id='1504' class=''>	mov [os_eth_rx_buffer+8], rax</p><p id='1505' class=''>	mov eax, 0xC0001FF8			; Set bits 31 (Ownership) and 30 (End of Descriptor Ring), also buffer size (Max 0x1FF8)</p><p id='1506' class=''>	mov [os_eth_rx_buffer+16], eax</p><p id='1507' class=''>	mov rax, os_ethernet_rx_buffer</p><p id='1508' class=''>	mov [os_eth_rx_buffer+24], rax</p><p id='1509' class=''></p><p id='1510' class=''>	; Initialize multicast registers (no filtering)</p><p id='1511' class=''>	mov eax, 0xFFFFFFFF</p><p id='1512' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1513' class=''>	add dx, RTL8169_REG_MAR0</p><p id='1514' class=''>	out dx, eax</p><p id='1515' class=''>	add dx, 4				; MAR4</p><p id='1516' class=''>	out dx, eax</p><p id='1517' class=''></p><p id='1518' class=''>	; Enable Rx/Tx in the Command register</p><p id='1519' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1520' class=''>	add dx, RTL8169_REG_COMMAND</p><p id='1521' class=''>	mov al, (1 << RTL8169_BIT_RE) | (1 << RTL8169_BIT_TE) ;0x0C				; Set bits 2 (TE) and 3 (RE)</p><p id='1522' class=''>	out dx, al</p><p id='1523' class=''></p><p id='1524' class=''>	; Enable Receive and Transmit interrupts</p><p id='1525' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1526' class=''>	add dx, RTL8169_REG_IMR</p><p id='1527' class=''>	mov ax, 0x0005				; Set bits 0 (RX OK) and 2 (TX OK)</p><p id='1528' class=''>	out dx, ax</p><p id='1529' class=''></p><p id='1530' class=''>	; Lock config register</p><p id='1531' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1532' class=''>	add dx, RTL8169_REG_9346CR</p><p id='1533' class=''>	mov al, 0x00				; Lock</p><p id='1534' class=''>	out dx, al</p><p id='1535' class=''></p><p id='1536' class=''>	pop rax</p><p id='1537' class=''>	pop rcx</p><p id='1538' class=''>	pop rdx</p><p id='1539' class=''>	ret</p><p id='1540' class=''>; -----------------------------------------------------------------------------</p><p id='1541' class=''></p><p id='1542' class=''></p><p id='1543' class=''>; -----------------------------------------------------------------------------</p><p id='1544' class=''>; os_net_rtl8169_transmit - Transmit a packet via a Realtek 8169 NIC</p><p id='1545' class=''>;  IN:	RSI = Location of packet</p><p id='1546' class=''>;	RCX = Length of packet</p><p id='1547' class=''>; OUT:	Nothing</p><p id='1548' class=''>;	Uses RAX, RCX, RDX, RSI, RDI</p><p id='1549' class=''>; ToDo:	Check for proper timeout</p><p id='1550' class=''>os_net_rtl8169_transmit:</p><p id='1551' class=''>	mov rdi, os_eth_tx_buffer</p><p id='1552' class=''>	mov rax, rcx</p><p id='1553' class=''>	stosw					; Store the frame length</p><p id='1554' class=''>	add rdi, 6				; Should the other data be cleared here?</p><p id='1555' class=''>	mov rax, rsi</p><p id='1556' class=''>	stosq					; Store the packet location</p><p id='1557' class=''>	or dword [os_eth_tx_buffer], 0xF0000000	; Set bit 31 (OWN), 30 (EOR), 29 (FS), and 28 (LS)</p><p id='1558' class=''>	mov dx, word [os_NetIOAddress]</p><p id='1559' class=''>	add dx, RTL8169_REG_TPPOLL</p><p id='1560' class=''>	mov al, 0x40</p><p id='1561' class=''>	out dx, al				; Set up TX Polling</p><p id='1562' class=''>os_net_rtl8169_transmit_sendloop:</p><p id='1563' class=''>	mov eax, [os_eth_tx_buffer]</p><p id='1564' class=''>	and eax, 0x80000000			; Check the ownership bit (BT command instead?)</p><p id='1565' class=''>	cmp eax, 0x80000000			; If the ownership bit is clear then the NIC sent the packet</p><p id='1566' class=''>	je os_net_rtl8169_transmit_sendloop</p><p id='1567' class=''>	ret</p><p id='1568' class=''>; -----------------------------------------------------------------------------</p><p id='1569' class=''></p><p id='1570' class=''></p><p id='1571' class=''>; -----------------------------------------------------------------------------</p><p id='1572' class=''>; os_net_rtl8169_poll - Polls the Realtek 8169 NIC for a received packet</p><p id='1573' class=''>;  IN:	RDI = Location to store packet</p><p id='1574' class=''>; OUT:	RCX = Length of packet</p><p id='1575' class=''>;	Uses RAX, RCX, RDX, RSI, RDI</p><p id='1576' class=''>os_net_rtl8169_poll:</p><p id='1577' class=''>	xor ecx, ecx</p><p id='1578' class=''>	mov cx, [os_eth_rx_buffer]</p><p id='1579' class=''>	and cx, 0x3FFF				; Clear the two high bits as length is bits 13-0</p><p id='1580' class=''>	cmp cx, 0x1FF8</p><p id='1581' class=''>	jne os_net_rtl8169_poll_first_descriptor</p><p id='1582' class=''>	mov cx, [os_eth_rx_buffer+16]</p><p id='1583' class=''>	and cx, 0x3FFF				; Clear the two high bits as length is bits 13-0</p><p id='1584' class=''>os_net_rtl8169_poll_first_descriptor:</p><p id='1585' class=''>	mov rsi, os_ethernet_rx_buffer</p><p id='1586' class=''>	push rcx</p><p id='1587' class=''>	rep movsb				; Copy the packet to the lacation stored in RDI</p><p id='1588' class=''>	pop rcx</p><p id='1589' class=''>	mov eax, 0x80001FF8			; Set bits 31 (Ownership), also buffer size (Max 0x1FF8)</p><p id='1590' class=''>	mov [os_eth_rx_buffer], eax</p><p id='1591' class=''>	mov rax, os_ethernet_rx_buffer</p><p id='1592' class=''>	mov [os_eth_rx_buffer+8], rax</p><p id='1593' class=''>	mov eax, 0xC0001FF8			; Set bits 31 (Ownership) and 30 (End of Descriptor Ring), also buffer size (Max 0x1FF8)</p><p id='1594' class=''>	mov [os_eth_rx_buffer+16], eax</p><p id='1595' class=''>	mov rax, os_ethernet_rx_buffer</p><p id='1596' class=''>	mov [os_eth_rx_buffer+24], rax</p><p id='1597' class=''>	ret</p><p id='1598' class=''>; -----------------------------------------------------------------------------</p><p id='1599' class=''></p><p id='1600' class=''></p><p id='1601' class=''>; -----------------------------------------------------------------------------</p><p id='1602' class=''>; os_net_rtl8169_ack_int - Acknowledge an internal interrupt of the Realtek 8169 NIC</p><p id='1603' class=''>;  IN:	Nothing</p><p id='1604' class=''>; OUT:	RAX = Ethernet status</p><p id='1605' class=''>;	Uses RDI</p><p id='1606' class=''>os_net_rtl8169_ack_int:</p><p id='1607' class=''>	push rdx</p><p id='1608' class=''>	mov dx, word [os_NetIOAddress]		; Clear active interrupt sources</p><p id='1609' class=''>	add dx, RTL8169_REG_ISR</p><p id='1610' class=''>	in ax, dx</p><p id='1611' class=''>	out dx, ax</p><p id='1612' class=''>	shr eax, 2</p><p id='1613' class=''>	pop rdx</p><p id='1614' class=''>	ret</p><p id='1615' class=''>; -----------------------------------------------------------------------------</p><p id='1616' class=''></p><p id='1617' class=''></p><p id='1618' class=''>; Register Descriptors</p><p id='1619' class=''>	RTL8169_REG_IDR0	equ 0x00	; ID Register 0</p><p id='1620' class=''>	RTL8169_REG_IDR1	equ 0x01	; ID Register 1</p><p id='1621' class=''>	RTL8169_REG_IDR2	equ 0x02	; ID Register 2</p><p id='1622' class=''>	RTL8169_REG_IDR3	equ 0x03	; ID Register 3</p><p id='1623' class=''>	RTL8169_REG_IDR4	equ 0x04	; ID Register 4</p><p id='1624' class=''>	RTL8169_REG_IDR5	equ 0x05	; ID Register 5</p><p id='1625' class=''>	RTL8169_REG_MAR0	equ 0x08	; Multicast Register 0</p><p id='1626' class=''>	RTL8169_REG_MAR1	equ 0x09	; Multicast Register 1</p><p id='1627' class=''>	RTL8169_REG_MAR2	equ 0x0A	; Multicast Register 2</p><p id='1628' class=''>	RTL8169_REG_MAR3	equ 0x0B	; Multicast Register 3</p><p id='1629' class=''>	RTL8169_REG_MAR4	equ 0x0C	; Multicast Register 4</p><p id='1630' class=''>	RTL8169_REG_MAR5	equ 0x0D	; Multicast Register 5</p><p id='1631' class=''>	RTL8169_REG_MAR6	equ 0x0E	; Multicast Register 6</p><p id='1632' class=''>	RTL8169_REG_MAR7	equ 0x0F	; Multicast Register 7</p><p id='1633' class=''>	RTL8169_REG_TNPDS	equ 0x20	; Transmit Normal Priority Descriptors: Start address (64-bit). (256-byte alignment) </p><p id='1634' class=''>	RTL8169_REG_COMMAND	equ 0x37	; Command Register</p><p id='1635' class=''>	RTL8169_REG_TPPOLL	equ 0x38	; Transmit Priority Polling Register</p><p id='1636' class=''>	RTL8169_REG_IMR		equ 0x3C	; Interrupt Mask Register</p><p id='1637' class=''>	RTL8169_REG_ISR		equ 0x3E	; Interrupt Status Register</p><p id='1638' class=''>	RTL8169_REG_TCR		equ 0x40	; Transmit (Tx) Configuration Register</p><p id='1639' class=''>	RTL8169_REG_RCR		equ 0x44	; Receive (Rx) Configuration Register</p><p id='1640' class=''>	RTL8169_REG_9346CR	equ 0x50	; 93C46 (93C56) Command Register</p><p id='1641' class=''>	RTL8169_REG_CONFIG0	equ 0x51	; Configuration Register 0</p><p id='1642' class=''>	RTL8169_REG_CONFIG1	equ 0x52	; Configuration Register 1</p><p id='1643' class=''>	RTL8169_REG_CONFIG2	equ 0x53	; Configuration Register 2</p><p id='1644' class=''>	RTL8169_REG_CONFIG3	equ 0x54	; Configuration Register 3</p><p id='1645' class=''>	RTL8169_REG_CONFIG4	equ 0x55	; Configuration Register 4</p><p id='1646' class=''>	RTL8169_REG_CONFIG5	equ 0x56	; Configuration Register 5</p><p id='1647' class=''>	RTL8169_REG_PHYAR	equ 0x60	; PHY Access Register </p><p id='1648' class=''>	RTL8169_REG_PHYStatus	equ 0x6C	; PHY(GMII, MII, or TBI) Status Register </p><p id='1649' class=''>	RTL8169_REG_MAXRX	equ 0xDA	; Mac Receive Packet Size Register</p><p id='1650' class=''>	RTL8169_REG_CCR		equ 0xE0	; C+ Command Register</p><p id='1651' class=''>	RTL8169_REG_RDSAR	equ 0xE4	; Receive Descriptor Start Address Register (256-byte alignment)</p><p id='1652' class=''>	RTL8169_REG_MAXTX	equ 0xEC	; Max Transmit Packet Size Register</p><p id='1653' class=''></p><p id='1654' class=''>; Command Register (Offset 0037h, R/W)	</p><p id='1655' class=''>	RTL8169_BIT_RST		equ 4		; Reset</p><p id='1656' class=''>	RTL8169_BIT_RE		equ 3		; Receiver Enable</p><p id='1657' class=''>	RTL8169_BIT_TE		equ 2		; Transmitter Enable</p><p id='1658' class=''></p><p id='1659' class=''>; Receive Configuration (Offset 0044h-0047h, R/W)</p><p id='1660' class=''>	RTL8169_BIT_AER		equ 5		; Accept Error</p><p id='1661' class=''>	RTL8169_BIT_AR		equ 4		; Accept Runt</p><p id='1662' class=''>	RTL8169_BIT_AB		equ 3		; Accept Broadcast Packets</p><p id='1663' class=''>	RTL8169_BIT_AM		equ 2		; Accept Multicast Packets</p><p id='1664' class=''>	RTL8169_BIT_APM		equ 1		; Accept Physical Match Packets</p><p id='1665' class=''>	RTL8169_BIT_AAP		equ 0		; Accept All Packets with Destination Address</p><p id='1666' class=''></p><p id='1667' class=''>; PHY Register Table</p><p id='1668' class=''>; BMCR (address 0x00) </p><p id='1669' class=''>	RTL8169_BIT_ANE		equ 12		; Auto-Negotiation Enable</p><p id='1670' class=''></p><p id='1671' class=''></p><p id='1672' class=''>; =============================================================================</p><p id='1673' class=''>; EOHEF</p><p id='1674' class=''>; =============================================================================</p><p id='1675' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='1676' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='1677' class=''>;</p><p id='1678' class=''>; AHCI Driver</p><p id='1679' class=''>; =============================================================================</p><p id='1680' class=''></p><p id='1681' class=''>align 16</p><p id='1682' class=''>db 'DEBUG: AHCI     '</p><p id='1683' class=''>align 16</p><p id='1684' class=''></p><p id='1685' class=''></p><p id='1686' class=''>; -----------------------------------------------------------------------------</p><p id='1687' class=''>init_ahci:</p><p id='1688' class=''>	mov rsi, diskmsg</p><p id='1689' class=''>	call os_output</p><p id='1690' class=''></p><p id='1691' class=''>; Probe for an AHCI hard drive controller</p><p id='1692' class=''>	xor ebx, ebx			; Clear the Bus number</p><p id='1693' class=''>	xor ecx, ecx			; Clear the Device/Slot number</p><p id='1694' class=''>	mov edx, 2			; Register 2 for Class code/Subclass</p><p id='1695' class=''></p><p id='1696' class=''>init_ahci_probe_next:</p><p id='1697' class=''>	call os_pci_read_reg</p><p id='1698' class=''>	shr eax, 16			; Move the Class/Subclass code to AX</p><p id='1699' class=''>	cmp ax, 0x0106			; Mass Storage Controller (01) / SATA Controller (06)</p><p id='1700' class=''>	je init_ahci_found		; Found a SATA Controller</p><p id='1701' class=''>	add ecx, 1</p><p id='1702' class=''>	cmp ecx, 256			; Maximum 256 devices/functions per bus</p><p id='1703' class=''>	je init_ahci_probe_next_bus</p><p id='1704' class=''>	jmp init_ahci_probe_next</p><p id='1705' class=''></p><p id='1706' class=''>init_ahci_probe_next_bus:</p><p id='1707' class=''>	xor ecx, ecx</p><p id='1708' class=''>	add ebx, 1</p><p id='1709' class=''>	cmp ebx, 256			; Maximum 256 buses</p><p id='1710' class=''>	je init_ahci_err_noahci</p><p id='1711' class=''>	jmp init_ahci_probe_next</p><p id='1712' class=''></p><p id='1713' class=''>init_ahci_found:</p><p id='1714' class=''>	mov dl, 9</p><p id='1715' class=''>	xor eax, eax</p><p id='1716' class=''>	call os_pci_read_reg		; BAR5 (AHCI Base Address Register)</p><p id='1717' class=''>	mov [ahci_base], rax</p><p id='1718' class=''></p><p id='1719' class=''>; Basic config of the controller, port 0</p><p id='1720' class=''>	mov rsi, rax			; RSI holds the ABAR</p><p id='1721' class=''>	mov rdi, rsi</p><p id='1722' class=''></p><p id='1723' class=''>; Search the implemented ports for a drive</p><p id='1724' class=''>	mov eax, [rsi+0x0C]		; PI  Ports Implemented</p><p id='1725' class=''>	mov edx, eax</p><p id='1726' class=''>	xor ecx, ecx</p><p id='1727' class=''>	mov ebx, 0x128			; Offset to Port 0 Serial ATA Status</p><p id='1728' class=''>nextport:</p><p id='1729' class=''>	bt edx, 0			; Valid port?</p><p id='1730' class=''>	jnc nodrive</p><p id='1731' class=''>	mov eax, [rsi+rbx]</p><p id='1732' class=''>	cmp eax, 0</p><p id='1733' class=''>	je nodrive</p><p id='1734' class=''>	jmp founddrive</p><p id='1735' class=''></p><p id='1736' class=''>nodrive:</p><p id='1737' class=''>	add ecx, 1</p><p id='1738' class=''>	shr edx, 1</p><p id='1739' class=''>	add ebx, 0x80			; Each port has a 128 byte memory space</p><p id='1740' class=''>	cmp ecx, 32</p><p id='1741' class=''>	je hdd_setup_err_nodisk</p><p id='1742' class=''>	jmp nextport</p><p id='1743' class=''></p><p id='1744' class=''>; Configure the first port found with a drive attached</p><p id='1745' class=''>founddrive:</p><p id='1746' class=''>	mov [ahci_port], ecx</p><p id='1747' class=''>	mov rdi, rsi</p><p id='1748' class=''>	add rdi, 0x100			; Offset to port 0</p><p id='1749' class=''>	push rcx				; Save port number</p><p id='1750' class=''>	shl rcx, 7			; Quick multiply by 0x80</p><p id='1751' class=''>	add rdi, rcx</p><p id='1752' class=''>	pop rcx				; Restore port number</p><p id='1753' class=''>	mov rax, ahci_cmdlist		; 1024 bytes per port</p><p id='1754' class=''>	stosd				; Offset 00h: PxCLB  Port x Command List Base Address</p><p id='1755' class=''>	xor eax, eax</p><p id='1756' class=''>	stosd				; Offset 04h: PxCLBU  Port x Command List Base Address Upper 32-bits</p><p id='1757' class=''>	mov rax, ahci_cmdlist + 0x1000	; 256 or 4096 bytes per port</p><p id='1758' class=''>	stosd				; Offset 08h: PxFB  Port x FIS Base Address</p><p id='1759' class=''>	xor eax, eax</p><p id='1760' class=''>	stosd				; Offset 0Ch: PxFBU  Port x FIS Base Address Upper 32-bits</p><p id='1761' class=''>	stosd				; Offset 10h: PxIS  Port x Interrupt Status</p><p id='1762' class=''>	stosd				; Offset 14h: PxIE  Port x Interrupt Enable</p><p id='1763' class=''></p><p id='1764' class=''>	; Query drive</p><p id='1765' class=''>	mov rdi, 0x200000</p><p id='1766' class=''>	call iddrive</p><p id='1767' class=''>	mov rsi, 0x200000</p><p id='1768' class=''>	mov eax, [rsi+200]		; Max LBA Extended</p><p id='1769' class=''>	shr rax, 11			; rax = rax * 512 / 1048576	MiB</p><p id='1770' class=''>;	shr rax, 21			; rax = rax * 512 / 1073741824	GiB</p><p id='1771' class=''>	mov [hd1_size], eax		; in mebibytes (MiB)</p><p id='1772' class=''>	mov rdi, os_temp_string</p><p id='1773' class=''>	mov rsi, rdi</p><p id='1774' class=''>	call os_int_to_string</p><p id='1775' class=''>	call os_output</p><p id='1776' class=''>	mov rsi, mibmsg</p><p id='1777' class=''>	call os_output</p><p id='1778' class=''></p><p id='1779' class=''>	; Found a bootable drive</p><p id='1780' class=''>	mov byte [os_DiskEnabled], 0x01</p><p id='1781' class=''></p><p id='1782' class=''>	ret</p><p id='1783' class=''></p><p id='1784' class=''>init_ahci_err_noahci:</p><p id='1785' class=''>hdd_setup_err_nodisk:</p><p id='1786' class=''>	mov rsi, namsg</p><p id='1787' class=''>	call os_output</p><p id='1788' class=''></p><p id='1789' class=''>	ret</p><p id='1790' class=''>; -----------------------------------------------------------------------------</p><p id='1791' class=''></p><p id='1792' class=''></p><p id='1793' class=''>; -----------------------------------------------------------------------------</p><p id='1794' class=''>; iddrive -- Identify a SATA drive</p><p id='1795' class=''>; IN:	RCX = Port # to query</p><p id='1796' class=''>;	RDI = memory location to store details (512 bytes)</p><p id='1797' class=''>; OUT:	Nothing, all registers preserved</p><p id='1798' class=''>iddrive:</p><p id='1799' class=''>	push rdi</p><p id='1800' class=''>	push rsi</p><p id='1801' class=''>	push rcx</p><p id='1802' class=''>	push rax</p><p id='1803' class=''></p><p id='1804' class=''>	shl rcx, 7			; Quick multiply by 0x80</p><p id='1805' class=''>	add rcx, 0x100			; Offset to port 0</p><p id='1806' class=''></p><p id='1807' class=''>	push rdi				; Save the destination memory address</p><p id='1808' class=''></p><p id='1809' class=''>	mov rsi, [ahci_base]</p><p id='1810' class=''></p><p id='1811' class=''>	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)</p><p id='1812' class=''>	xor eax, eax</p><p id='1813' class=''>	mov eax, 0x00010005 ;4		; 1 PRDTL Entry, Command FIS Length = 16 bytes</p><p id='1814' class=''>	stosd				; DW 0 - Description Information</p><p id='1815' class=''>	xor eax, eax</p><p id='1816' class=''>	stosd				; DW 1 - Command Status</p><p id='1817' class=''>	mov eax, ahci_cmdtable</p><p id='1818' class=''>	stosd				; DW 2 - Command Table Base Address</p><p id='1819' class=''>	xor eax, eax</p><p id='1820' class=''>	stosd				; DW 3 - Command Table Base Address Upper</p><p id='1821' class=''>	stosd</p><p id='1822' class=''>	stosd</p><p id='1823' class=''>	stosd</p><p id='1824' class=''>	stosd</p><p id='1825' class=''>	; DW 4 - 7 are reserved</p><p id='1826' class=''></p><p id='1827' class=''>	; command table</p><p id='1828' class=''>	mov rdi, ahci_cmdtable		; Build a command table for Port 0</p><p id='1829' class=''>	mov eax, 0x00EC8027		; EC identify, bit 15 set, fis 27 H2D</p><p id='1830' class=''>	stosd				; feature 7:0, command, c, fis</p><p id='1831' class=''>	xor eax, eax</p><p id='1832' class=''>	stosd				; device, lba 23:16, lba 15:8, lba 7:0</p><p id='1833' class=''>	stosd				; feature 15:8, lba 47:40, lba 39:32, lba 31:24</p><p id='1834' class=''>	stosd				; control, ICC, count 15:8, count 7:0</p><p id='1835' class=''>;	stosd				; reserved</p><p id='1836' class=''>	mov rdi, ahci_cmdtable + 0x80</p><p id='1837' class=''>	pop rax				; Restore the destination memory address</p><p id='1838' class=''>	stosd				; Data Base Address</p><p id='1839' class=''>	shr rax, 32</p><p id='1840' class=''>	stosd				; Data Base Address Upper</p><p id='1841' class=''>	xor eax, eax</p><p id='1842' class=''>	stosd				; Reserved</p><p id='1843' class=''>	mov eax, 0x000001FF		; 512 - 1</p><p id='1844' class=''>	stosd				; Description Information</p><p id='1845' class=''></p><p id='1846' class=''>	add rsi, rcx</p><p id='1847' class=''></p><p id='1848' class=''>	mov rdi, rsi</p><p id='1849' class=''>	add rdi, 0x10			; Port x Interrupt Status</p><p id='1850' class=''>	xor eax, eax</p><p id='1851' class=''>	stosd</p><p id='1852' class=''></p><p id='1853' class=''>	mov rdi, rsi</p><p id='1854' class=''>	add rdi, 0x18			; Offset to port 0 Command and Status</p><p id='1855' class=''>	mov eax, [rdi]</p><p id='1856' class=''>	bts eax, 4			; FRE</p><p id='1857' class=''>	bts eax, 0			; ST</p><p id='1858' class=''>	stosd</p><p id='1859' class=''></p><p id='1860' class=''>	mov rdi, rsi</p><p id='1861' class=''>	add rdi, 0x38			; Command Issue</p><p id='1862' class=''>	mov eax, 0x00000001		; Execute Command Slot 0</p><p id='1863' class=''>	stosd</p><p id='1864' class=''></p><p id='1865' class=''>iddrive_poll:</p><p id='1866' class=''>	mov eax, [rsi+0x38]</p><p id='1867' class=''>	cmp eax, 0</p><p id='1868' class=''>	jne iddrive_poll</p><p id='1869' class=''></p><p id='1870' class=''>	mov rdi, rsi</p><p id='1871' class=''>	add rdi, 0x18			; Offset to port 0</p><p id='1872' class=''>	mov eax, [rdi]</p><p id='1873' class=''>	btc eax, 4			; FRE</p><p id='1874' class=''>	btc eax, 0			; ST</p><p id='1875' class=''>	stosd</p><p id='1876' class=''></p><p id='1877' class=''>	pop rax</p><p id='1878' class=''>	pop rcx</p><p id='1879' class=''>	pop rsi</p><p id='1880' class=''>	pop rdi</p><p id='1881' class=''>ret</p><p id='1882' class=''>; -----------------------------------------------------------------------------</p><p id='1883' class=''></p><p id='1884' class=''></p><p id='1885' class=''>; -----------------------------------------------------------------------------</p><p id='1886' class=''>; readsectors -- Read data from a SATA hard drive</p><p id='1887' class=''>; IN:	RAX = starting sector # to read</p><p id='1888' class=''>;	RCX = number of sectors to read (up to 8192 = 4MiB)</p><p id='1889' class=''>;	RDX = disk #</p><p id='1890' class=''>;	RDI = memory location to store sectors</p><p id='1891' class=''>; OUT:	RAX = RAX + number of sectors that were read</p><p id='1892' class=''>;	RCX = number of sectors that were read (0 on error)</p><p id='1893' class=''>;	RDI = RDI + (number of sectors read * 512)</p><p id='1894' class=''>;	All other registers preserved</p><p id='1895' class=''>readsectors:</p><p id='1896' class=''>	push rdx</p><p id='1897' class=''>	push rbx</p><p id='1898' class=''>	push rdi</p><p id='1899' class=''>	push rsi</p><p id='1900' class=''>	push rcx</p><p id='1901' class=''>	push rax</p><p id='1902' class=''></p><p id='1903' class=''>	push rcx				; Save the sector count</p><p id='1904' class=''>	push rdi				; Save the destination memory address</p><p id='1905' class=''>	push rax				; Save the block number</p><p id='1906' class=''>	push rax</p><p id='1907' class=''></p><p id='1908' class=''>	shl rdx, 7			; Quick multiply by 0x80</p><p id='1909' class=''>	add rdx, 0x100			; Offset to port 0</p><p id='1910' class=''></p><p id='1911' class=''>	mov rsi, [ahci_base]</p><p id='1912' class=''></p><p id='1913' class=''>	; Command list setup</p><p id='1914' class=''>	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)</p><p id='1915' class=''>	xor eax, eax</p><p id='1916' class=''>	mov eax, 0x00010005		; 1 PRDTL Entry, Command FIS Length = 20 bytes</p><p id='1917' class=''>	stosd				; DW 0 - Description Information</p><p id='1918' class=''>	xor eax, eax</p><p id='1919' class=''>	stosd				; DW 1 - Command Status</p><p id='1920' class=''>	mov eax, ahci_cmdtable</p><p id='1921' class=''>	stosd				; DW 2 - Command Table Base Address</p><p id='1922' class=''>	xor eax, eax</p><p id='1923' class=''>	stosd				; DW 3 - Command Table Base Address Upper</p><p id='1924' class=''>	stosd</p><p id='1925' class=''>	stosd</p><p id='1926' class=''>	stosd</p><p id='1927' class=''>	stosd</p><p id='1928' class=''>	; DW 4 - 7 are reserved</p><p id='1929' class=''></p><p id='1930' class=''>	; Command FIS setup</p><p id='1931' class=''>	mov rdi, ahci_cmdtable		; Build a command table for Port 0</p><p id='1932' class=''>	mov eax, 0x00258027		; 25 READ DMA EXT, bit 15 set, fis 27 H2D</p><p id='1933' class=''>	stosd				; feature 7:0, command, c, fis</p><p id='1934' class=''>	pop rax				; Restore the start sector number</p><p id='1935' class=''>	shl rax, 36</p><p id='1936' class=''>	shr rax, 36			; Upper 36 bits cleared</p><p id='1937' class=''>	bts rax, 30			; bit 30 set for LBA</p><p id='1938' class=''>	stosd				; device, lba 23:16, lba 15:8, lba 7:0</p><p id='1939' class=''>	pop rax				; Restore the start sector number</p><p id='1940' class=''>	shr rax, 24</p><p id='1941' class=''>	stosd				; feature 15:8, lba 47:40, lba 39:32, lba 31:24</p><p id='1942' class=''>	mov rax, rcx			; Read the number of sectors given in rcx</p><p id='1943' class=''>	stosd				; control, ICC, count 15:8, count 7:0</p><p id='1944' class=''>	mov rax, 0x00000000</p><p id='1945' class=''>	stosd				; reserved</p><p id='1946' class=''></p><p id='1947' class=''>	; PRDT setup</p><p id='1948' class=''>	mov rdi, ahci_cmdtable + 0x80</p><p id='1949' class=''>	pop rax				; Restore the destination memory address</p><p id='1950' class=''>	stosd				; Data Base Address</p><p id='1951' class=''>	shr rax, 32</p><p id='1952' class=''>	stosd				; Data Base Address Upper</p><p id='1953' class=''>	stosd				; Reserved</p><p id='1954' class=''>	pop rax				; Restore the sector count</p><p id='1955' class=''>	shl rax, 9			; multiply by 512 for bytes</p><p id='1956' class=''>	sub rax, 1			; subtract 1 (4.2.3.3, DBC is number of bytes - 1)</p><p id='1957' class=''>	stosd				; Description Information</p><p id='1958' class=''></p><p id='1959' class=''>	add rsi, rdx</p><p id='1960' class=''></p><p id='1961' class=''>	mov rdi, rsi</p><p id='1962' class=''>	add rdi, 0x10			; Port x Interrupt Status</p><p id='1963' class=''>	xor eax, eax</p><p id='1964' class=''>	stosd</p><p id='1965' class=''></p><p id='1966' class=''>	mov rdi, rsi</p><p id='1967' class=''>	add rdi, 0x18			; Offset to port 0</p><p id='1968' class=''>	mov eax, [rdi]</p><p id='1969' class=''>	bts eax, 4			; FRE</p><p id='1970' class=''>	bts eax, 0			; ST</p><p id='1971' class=''>	stosd</p><p id='1972' class=''></p><p id='1973' class=''>	mov rdi, rsi</p><p id='1974' class=''>	add rdi, 0x38			; Command Issue</p><p id='1975' class=''>	mov eax, 0x00000001		; Execute Command Slot 0</p><p id='1976' class=''>	stosd</p><p id='1977' class=''></p><p id='1978' class=''>readsectors_poll:</p><p id='1979' class=''>	mov eax, [rsi+0x38]</p><p id='1980' class=''>	cmp eax, 0</p><p id='1981' class=''>	jne readsectors_poll</p><p id='1982' class=''></p><p id='1983' class=''>	mov rdi, rsi</p><p id='1984' class=''>	add rdi, 0x18			; Offset to port 0</p><p id='1985' class=''>	mov eax, [rdi]</p><p id='1986' class=''>	btc eax, 4			; FRE</p><p id='1987' class=''>	btc eax, 0			; ST</p><p id='1988' class=''>	stosd</p><p id='1989' class=''></p><p id='1990' class=''>	pop rax				; rax = start</p><p id='1991' class=''>	pop rcx				; rcx = number of sectors read</p><p id='1992' class=''>	add rax, rcx			; rax = start + number of sectors read</p><p id='1993' class=''>	pop rsi</p><p id='1994' class=''>	pop rdi</p><p id='1995' class=''>	mov rbx, rcx			; rdi = dest addr + number of bytes read</p><p id='1996' class=''>	shl rbx, 9</p><p id='1997' class=''>	add rdi, rbx</p><p id='1998' class=''>	pop rbx</p><p id='1999' class=''>	pop rdx</p><p id='2000' class=''>ret</p><p id='2001' class=''>; -----------------------------------------------------------------------------</p><p id='2002' class=''></p><p id='2003' class=''></p><p id='2004' class=''>; -----------------------------------------------------------------------------</p><p id='2005' class=''>; writesectors -- Write data to a SATA hard drive</p><p id='2006' class=''>; IN:	RAX = starting sector # to write</p><p id='2007' class=''>;	RCX = number of sectors to write (up to 8192 = 4MiB)</p><p id='2008' class=''>;	RDX = disk #</p><p id='2009' class=''>;	RSI = memory location of sectors</p><p id='2010' class=''>; OUT:	RAX = RAX + number of sectors that were written</p><p id='2011' class=''>;	RCX = number of sectors that were written (0 on error)</p><p id='2012' class=''>;	RSI = RSI + (number of sectors written * 512)</p><p id='2013' class=''>;	All other registers preserved</p><p id='2014' class=''>writesectors:</p><p id='2015' class=''>	push rdx</p><p id='2016' class=''>	push rbx</p><p id='2017' class=''>	push rdi</p><p id='2018' class=''>	push rsi</p><p id='2019' class=''>	push rcx</p><p id='2020' class=''>	push rax</p><p id='2021' class=''></p><p id='2022' class=''>	push rcx				; Save the sector count</p><p id='2023' class=''>	push rsi				; Save the source memory address</p><p id='2024' class=''>	push rax				; Save the block number</p><p id='2025' class=''>	push rax</p><p id='2026' class=''></p><p id='2027' class=''>	shl rdx, 7			; Quick multiply by 0x80</p><p id='2028' class=''>	add rdx, 0x100			; Offset to port 0</p><p id='2029' class=''></p><p id='2030' class=''>	mov rsi, [ahci_base]</p><p id='2031' class=''></p><p id='2032' class=''>	; Command list setup</p><p id='2033' class=''>	mov rdi, ahci_cmdlist		; command list (1K with 32 entries, 32 bytes each)</p><p id='2034' class=''>	xor eax, eax</p><p id='2035' class=''>	mov eax, 0x00010045		; 1 PRDTL Entry, write flag, Command FIS Length = 20 bytes</p><p id='2036' class=''>	stosd				; DW 0 - Description Information</p><p id='2037' class=''>	xor eax, eax</p><p id='2038' class=''>	stosd				; DW 1 - Command Status</p><p id='2039' class=''>	mov eax, ahci_cmdtable</p><p id='2040' class=''>	stosd				; DW 2 - Command Table Base Address</p><p id='2041' class=''>	xor eax, eax</p><p id='2042' class=''>	stosd				; DW 3 - Command Table Base Address Upper</p><p id='2043' class=''>	stosd</p><p id='2044' class=''>	stosd</p><p id='2045' class=''>	stosd</p><p id='2046' class=''>	stosd</p><p id='2047' class=''>	; DW 4 - 7 are reserved</p><p id='2048' class=''></p><p id='2049' class=''>	; Command FIS setup</p><p id='2050' class=''>	mov rdi, ahci_cmdtable		; Build a command table for Port 0</p><p id='2051' class=''>	mov eax, 0x00358027		; 35 WRITE DMA EXT, bit 15 set, fis 27 H2D</p><p id='2052' class=''>	stosd				; feature 7:0, command, c, fis</p><p id='2053' class=''>	pop rax				; Restore the start sector number</p><p id='2054' class=''>	shl rax, 36</p><p id='2055' class=''>	shr rax, 36			; Upper 36 bits cleared</p><p id='2056' class=''>	bts rax, 30			; bit 30 set for LBA</p><p id='2057' class=''>	stosd				; device, lba 23:16, lba 15:8, lba 7:0</p><p id='2058' class=''>	pop rax				; Restore the start sector number</p><p id='2059' class=''>	shr rax, 24</p><p id='2060' class=''>	stosd				; feature 15:8, lba 47:40, lba 39:32, lba 31:24</p><p id='2061' class=''>	mov rax, rcx			; Read the number of sectors given in rcx</p><p id='2062' class=''>	stosd				; control, ICC, count 15:8, count 7:0</p><p id='2063' class=''>	mov rax, 0x00000000</p><p id='2064' class=''>	stosd				; reserved</p><p id='2065' class=''></p><p id='2066' class=''>	; PRDT setup</p><p id='2067' class=''>	mov rdi, ahci_cmdtable + 0x80</p><p id='2068' class=''>	pop rax				; Restore the source memory address</p><p id='2069' class=''></p><p id='2070' class=''>	stosd				; Data Base Address</p><p id='2071' class=''>	shr rax, 32</p><p id='2072' class=''>	stosd				; Data Base Address Upper</p><p id='2073' class=''>	stosd				; Reserved</p><p id='2074' class=''>	pop rax				; Restore the sector count</p><p id='2075' class=''>	shl rax, 9			; multiply by 512 for bytes</p><p id='2076' class=''>	add rax, -1			; subtract 1 (4.2.3.3, DBC is number of bytes - 1)</p><p id='2077' class=''>	stosd				; Description Information</p><p id='2078' class=''></p><p id='2079' class=''>	add rsi, rdx</p><p id='2080' class=''></p><p id='2081' class=''>	mov rdi, rsi</p><p id='2082' class=''>	add rdi, 0x10			; Port x Interrupt Status</p><p id='2083' class=''>	xor eax, eax</p><p id='2084' class=''>	stosd</p><p id='2085' class=''></p><p id='2086' class=''>	mov rdi, rsi</p><p id='2087' class=''>	add rdi, 0x18			; Offset to port 0</p><p id='2088' class=''>	mov eax, [rdi]</p><p id='2089' class=''>	bts eax, 4			; FRE</p><p id='2090' class=''>	bts eax, 0			; ST</p><p id='2091' class=''>	stosd</p><p id='2092' class=''></p><p id='2093' class=''>	mov rdi, rsi</p><p id='2094' class=''>	add rdi, 0x38			; Command Issue</p><p id='2095' class=''>	mov eax, 0x00000001		; Execute Command Slot 0</p><p id='2096' class=''>	stosd</p><p id='2097' class=''></p><p id='2098' class=''>writesectors_poll:</p><p id='2099' class=''>	mov eax, [rsi+0x38]</p><p id='2100' class=''>	cmp eax, 0</p><p id='2101' class=''>	jne writesectors_poll</p><p id='2102' class=''></p><p id='2103' class=''>	mov rdi, rsi</p><p id='2104' class=''>	add rdi, 0x18			; Offset to port 0</p><p id='2105' class=''>	mov eax, [rdi]</p><p id='2106' class=''>	btc eax, 4			; FRE</p><p id='2107' class=''>	btc eax, 0			; ST</p><p id='2108' class=''>	stosd</p><p id='2109' class=''></p><p id='2110' class=''>	pop rax				; rax = start</p><p id='2111' class=''>	pop rcx				; rcx = number of sectors read</p><p id='2112' class=''>	add rax, rcx			; rax = start + number of sectors written</p><p id='2113' class=''>	pop rsi</p><p id='2114' class=''>	pop rdi</p><p id='2115' class=''>	mov rbx, rcx			; rdi = dest addr + number of bytes written</p><p id='2116' class=''>	shl rbx, 9</p><p id='2117' class=''>	add rdi, rbx</p><p id='2118' class=''>	pop rbx</p><p id='2119' class=''>	pop rdx</p><p id='2120' class=''>ret</p><p id='2121' class=''>; -----------------------------------------------------------------------------</p><p id='2122' class=''></p><p id='2123' class=''></p><p id='2124' class=''>; =============================================================================</p><p id='2125' class=''>; EOHEF</p><p id='2126' class=''>; =============================================================================</p><p id='2127' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='2128' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='2129' class=''>;</p><p id='2130' class=''>; PCI Functions. http://wiki.osdev.org/PCI</p><p id='2131' class=''>; =============================================================================</p><p id='2132' class=''></p><p id='2133' class=''>align 16</p><p id='2134' class=''>db 'DEBUG: PCI      '</p><p id='2135' class=''>align 16</p><p id='2136' class=''></p><p id='2137' class=''></p><p id='2138' class=''>; -----------------------------------------------------------------------------</p><p id='2139' class=''>; os_pci_read_reg -- Read from a register on a PCI device</p><p id='2140' class=''>;  IN:	BL  = Bus number</p><p id='2141' class=''>;	CL  = Device/Slot/Function number</p><p id='2142' class=''>;	DL  = Register number (0-15)</p><p id='2143' class=''>; OUT:	EAX = Register information</p><p id='2144' class=''>;	All other registers preserved</p><p id='2145' class=''>os_pci_read_reg:</p><p id='2146' class=''>	push rdx</p><p id='2147' class=''>	push rcx</p><p id='2148' class=''>	push rbx</p><p id='2149' class=''></p><p id='2150' class=''>	shl ebx, 16			; Move Bus number to bits 23 - 16</p><p id='2151' class=''>	shl ecx, 8			; Move Device/Slot/Fuction number to bits 15 - 8</p><p id='2152' class=''>	mov bx, cx</p><p id='2153' class=''>	shl edx, 2</p><p id='2154' class=''>	mov bl, dl</p><p id='2155' class=''>	and ebx, 0x00ffffff		; Clear bits 31 - 24</p><p id='2156' class=''>	or ebx, 0x80000000		; Set bit 31</p><p id='2157' class=''>	mov eax, ebx</p><p id='2158' class=''>	mov dx, PCI_CONFIG_ADDRESS</p><p id='2159' class=''>	out dx, eax</p><p id='2160' class=''>	mov dx, PCI_CONFIG_DATA</p><p id='2161' class=''>	in eax, dx</p><p id='2162' class=''></p><p id='2163' class=''>	pop rbx</p><p id='2164' class=''>	pop rcx</p><p id='2165' class=''>	pop rdx</p><p id='2166' class=''>ret</p><p id='2167' class=''>; -----------------------------------------------------------------------------</p><p id='2168' class=''></p><p id='2169' class=''></p><p id='2170' class=''>; -----------------------------------------------------------------------------</p><p id='2171' class=''>; os_pci_write_reg -- Write to a register on a PCI device</p><p id='2172' class=''>;  IN:	BL  = Bus number</p><p id='2173' class=''>;	CL  = Device/Slot/Function number</p><p id='2174' class=''>;	DL  = Register number (0-15)</p><p id='2175' class=''>; OUT:	EAX = Register information</p><p id='2176' class=''>;	All other registers preserved</p><p id='2177' class=''>os_pci_write_reg:</p><p id='2178' class=''>	push rdx</p><p id='2179' class=''>	push rcx</p><p id='2180' class=''>	push rbx</p><p id='2181' class=''>	push rax</p><p id='2182' class=''></p><p id='2183' class=''>	shl ebx, 16			; Move Bus number to bits 23 - 16</p><p id='2184' class=''>	shl ecx, 8			; Move Device/Slot/Fuction number to bits 15 - 8</p><p id='2185' class=''>	mov bx, cx</p><p id='2186' class=''>	shl edx, 2</p><p id='2187' class=''>	mov bl, dl</p><p id='2188' class=''>	and ebx, 0x00ffffff		; Clear bits 31 - 24</p><p id='2189' class=''>	or ebx, 0x80000000		; Set bit 31</p><p id='2190' class=''>	mov eax, ebx</p><p id='2191' class=''>	mov dx, PCI_CONFIG_ADDRESS</p><p id='2192' class=''>	out dx, eax</p><p id='2193' class=''>	pop rax</p><p id='2194' class=''>	mov dx, PCI_CONFIG_DATA</p><p id='2195' class=''>	out dx, eax</p><p id='2196' class=''></p><p id='2197' class=''>	pop rbx</p><p id='2198' class=''>	pop rcx</p><p id='2199' class=''>	pop rdx</p><p id='2200' class=''>	ret</p><p id='2201' class=''>; -----------------------------------------------------------------------------</p><p id='2202' class=''></p><p id='2203' class=''></p><p id='2204' class=''>;Configuration Mechanism One has two IO port rages associated with it.</p><p id='2205' class=''>;The address port (0xcf8-0xcfb) and the data port (0xcfc-0xcff).</p><p id='2206' class=''>;A configuration cycle consists of writing to the address port to specify which device and register you want to access and then reading or writing the data to the data port.</p><p id='2207' class=''></p><p id='2208' class=''>PCI_CONFIG_ADDRESS	EQU	0x0CF8</p><p id='2209' class=''>PCI_CONFIG_DATA		EQU	0x0CFC</p><p id='2210' class=''></p><p id='2211' class=''>;ddress dd 10000000000000000000000000000000b</p><p id='2212' class=''>;          /\     /\      /\   /\ /\    /;        E    Res    Bus    Dev  F  Reg   0</p><p id='2213' class=''>; Bits</p><p id='2214' class=''>; 31		Enable bit = set to 1</p><p id='2215' class=''>; 30 - 24	Reserved = set to 0</p><p id='2216' class=''>; 23 - 16	Bus number = 256 options</p><p id='2217' class=''>; 15 - 11	Device/Slot number = 32 options</p><p id='2218' class=''>; 10 - 8	Function number = will leave at 0 (8 options)</p><p id='2219' class=''>; 7 - 2		Register number = will leave at 0 (64 options) 64 x 4 bytes = 256 bytes worth of accessible registers</p><p id='2220' class=''>; 1 - 0		Set to 0</p><p id='2221' class=''></p><p id='2222' class=''></p><p id='2223' class=''>; =============================================================================</p><p id='2224' class=''>; EOHEF</p><p id='2225' class=''>; =============================================================================</p><p id='2226' class=''>; BareMetal -- a 64-bit OS written in Assembly for x86-64 systems</p><p id='2227' class=''>; Copyright (C) 2008-2014 Return Infinity -- see LICENSE.TXT</p><p id='2228' class=''>;</p><p id='2229' class=''>; PIC Functions. http://wiki.osdev.org/PIC</p><p id='2230' class=''>; =============================================================================</p><p id='2231' class=''></p><p id='2232' class=''>align 16</p><p id='2233' class=''>db 'DEBUG: PIC      '</p><p id='2234' class=''>align 16</p><p id='2235' class=''></p><p id='2236' class=''></p><p id='2237' class=''>; -----------------------------------------------------------------------------</p><p id='2238' class=''>; os_pic_mask_clear -- Clear a mask on the PIC</p><p id='2239' class=''>;  IN:	AL  = IRQ #</p><p id='2240' class=''>; OUT:	All registers preserved</p><p id='2241' class=''>os_pic_mask_clear:</p><p id='2242' class=''>	push dx</p><p id='2243' class=''>	push bx</p><p id='2244' class=''>	push ax</p><p id='2245' class=''></p><p id='2246' class=''>	mov bl, al			; Save the IRQ value</p><p id='2247' class=''>	cmp bl, 8			; Less than 8</p><p id='2248' class=''>	jl os_pic_mask_clear_low	; If so, only set Master PIC</p><p id='2249' class=''>	mov dx, 0xA1			; Slave PIC data address</p><p id='2250' class=''>
		</div>
		<script>
		end = '<a href="index.html">The End</a>';
		cnt = 0;
		on = false;
		var recur = function() {
		if(on){
			return 0
		}
			if(cnt>5012){
				var newline = document.createElement('a');
				newline.setAttribute('href', 'index.html');
				newline.innerHTML = "The End";
				newline.setAttribute('id','r');
				document.getElementById("console").appendChild(newline);
				document.getElementById("r").focus();
				on = true;
			}
			else if (cnt>50){
				window.scrollBy(0,20);
				document.getElementById(Math.floor((Math.random() * 2250) + 1)).style.color = "#FF0000"
				cnt++;
			}
			
			window.requestAnimationFrame(recur);
		};
		var Key = {
		 _pressed: {},
		 left: 37, up:38, right:39, down:40,
		  
		isDown: function(keyCode) {
			return this._pressed[keyCode];
		},
		
		onKeydown: function(event) {
			if(event.keyCode == 8){
				event.preventDefault();
			}
			cnt++
		},
		  
		onKeyup: function(event) {
			if(event.keyCode == 16){
				Key.shift = false;
			}
		}
		};
		window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
		window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);
		sessionStorage.p4 = 1;
		window.requestAnimationFrame(recur);
		</script>
	</body>
</html>